## 八股文训练，carl训练营+小林coding redis和数据库

## 问题列表
1. HTTP请求报文和响应报文是怎么样的，有哪些常见字段

2. HTTP种常见的状态码有哪些

3.强缓存和协商缓存(HTTP机制)

4.HTTP 1.0,1.1,2.0,1.1,3.0

5. HTTPS和HTTP有哪些区别

6. HTTPS的工作原理(HTTPS建立连接的过程）

7. UDP怎么实现可靠传输

8. HTTP的keepalive是什么，TCP和HTTP的keepalive是一样的吗

9. CDN是什么，有什么作用？

10. cookie和session是什么

11. c++中的原子操作有哪些(https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E8%AE%B2%E4%B8%80%E8%AE%B2C++%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F.md)

12. 右值引用有什么作用(同上)

13.在C++中，对一个对象先malloc后delete这样使用可以吗。为什么 https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E5%9C%A8C%2B%2B%E4%B8%AD%EF%BC%8C%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%85%88malloc%E5%90%8Edelete%E8%BF%99%E6%A0%B7%E4%BD%BF%E7%94%A8%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E9%A3%8E%E9%99%A9.md

14. 进程间有哪些通信方式（day3.15）

15. 介绍一下几种典型的锁（day3.17)

16. 讲一讲你理解的虚拟内存（day3.17）

17. 你知道的线程同步的方式有哪些？(day3.18)(王道里的同步互斥问题)

18. 浅层拷贝有什么问题（https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E5%9C%A8C++%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F.md）

19. 怎么构造一个类只在堆上（用一个private函数建立数据）或者栈上(新建用new)使用内存

20. c++内存模型 （https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E4%BB%80%E4%B9%88%E6%98%AFC++%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F.md

21. 指针和引用在内存的表现形式如何（https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F.md）

22. 如果A这个对象对应的是一个空类，sizeofa是多少（是1，https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E5%A6%82%E6%9E%9CA%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%EF%BC%8C%E9%82%A3%E4%B9%88sizeof(A)%E7%9A%84%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F.md）

23. stl常见算法库 （https://github.com/youngyangyang04/TechCPP/blob/master/problems/STL%E4%B8%AD%E4%B8%80%E8%88%AC%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E5%BA%93%E5%91%A2%EF%BC%9F.md）

24. c++的map中，[]和insert有什么区别 (https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E5%9C%A8C++%E7%9A%84map%E4%B8%AD%EF%BC%8C%5B%5D%E4%B8%8Einsert%E6%9C%89%E9%82%A3%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F.md)

30. weak_ptr怎么解决sharedptr的循环引用问题（https://github.com/youngyangyang04/TechCPP/blob/master/problems/weak_ptr%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3shared_ptr%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%EF%BC%9F.md）

31. 如何用gdb来定位c++程序中的死锁（https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gdb%E6%9D%A5%E5%AE%9A%E4%BD%8DC++%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%EF%BC%9F.md）

32.c++中常用的类优化技术（https://github.com/youngyangyang04/TechCPP/blob/master/problems/C++%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F.md）

33. 原子变量的内存序是什么(https://github.com/youngyangyang04/TechCPP/blob/master/problems/%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.md)

34. 熟悉哪些linux命令 

35. Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用

36. 说一下 select、poll、epoll（IO多路复用方面的）

37. 一条SQL查询语句是如何执行的？

38. mysql的执行引擎有哪些

39. 索引失效的场景

40.什么是慢查询，什么原因，可以怎么优化

41. undo log、redo log、binlog 有什么用？

42. mysql和redis的区别

43. redis有什么优缺点，为什么redis查询比较快

44. redis的数据类型

45. redis是单线程还是多线程的，为什么

46.redis的持久化机制有哪些

## day1 317
今天训练营的题目补了几天的量，一开始https的都忘干净了，后面3 4 天的都是知识盲区，后面操作系统的主要是进程线程方面的熟悉起来了

### http

#### 3.5任务 tcp/ip和osi的区别
OSI模型， 是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，将计算机网络通信划分为七个不同的层级，每个层级都负责特定的功能。每个层级都构建在其下方的层级之上，并为上方的层级提供服务。七层从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。虽然OSI模型在理论上更全面，但在实际网络通信中，TCP/IP模型更为实用。 TCP/IP模型分为四个层级，每个层级负责特定的网络功能。

1. 应用层：该层与OSI模型的应用层和表示层以及会话层类似，提供直接与用户应用程序交互的接口。它为网络上的各种应用程序提供服务，如电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。
2. 传输层：该层对应OSI模型的传输层。它负责端到端的数据传输，提供可靠的、无连接的数据传输服务。主要的传输层协议有TCP和UDP。TCP提供可靠的数据传输，确保数据的正确性和完整性；而UDP则是无连接的，适用于不要求可靠性的传输，如实时音频和视频流。
3. 网络层：该层对应OSI模型的网络层。主要协议是IP，它负责数据包的路由和转发，选择最佳路径将数据从源主机传输到目标主机。IP协议使用IP地址来标识主机和网络，并进行逻辑地址寻址。
4. 网络接口层：该层对应OSI模型的数据链路层和物理层。它负责物理传输媒介的传输，例如以太网、Wi-Fi等，并提供错误检测和纠正的功能。此外，网络接口层还包含硬件地址（MAC地址）的管理。

osi模型明确定义了服务，协议，接口，tcpip没有，tcpip是对于现有协议的描述，不能迁移到其他协议栈，osi模型没有异构网络的链接，在网络层tcpip只有无连接，osi有有链接和无连接，传输层tcpip有有链接和无连接，osi只有有连接

#### 3.5任务 从输入 URL 到页面展示到底发生了什么？
1. 输入网址，解析URL信息，准备发送HTTP请求

2. 检查浏览器缓存里是否有缓存该资源，如果有直接返回；如果没有进入下一步网络请求。
3. DNS域名解析：网络请求前，进行DNS解析，以获取请求域名的IP地址。DNS解析时会按本地浏览器缓存->本地Host文件->路由器缓存->DNS服务器->根DNS服务器的顺序查询域名对应IP，直到找到为止。
4. TCP三次握手建立连接：浏览器与服务器IP建立TCP连接。
5. 客户端发送HTTP请求：连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。如果是HTTPS的话，还涉及到HTTPS的加解密流程。
6. 服务器处理请求并返回HTTP资源：服务器接收到请求信息，根据请求生成响应数据。
7. TCP四次挥手断开连接：浏览器与服务器IP断开TCP连接。
8. 浏览器解析响应并渲染页面：
    
    浏览器解析响应头。若响应头状态码为301、302，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部渲染流程。

    浏览器解析HTML文件，创建DOM树，解析CSS进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成页面展示。

#### 3.6 任务HTTP请求报文和响应报文是怎样的，有哪些常见的字段

HTTP报文分为请求报文和响应报文。

（1） 请求报文 请求报文主要由请求行、请求头、空行、请求体构成。 请求行包括如下字段：

方法（Method）：指定要执行的操作，如 GET、POST、PUT、DELETE 等。
资源路径（Resource Path）：请求的资源的URI（统一资源标识符）。
HTTP版本（HTTP Version）：使用的HTTP协议版本，如 HTTP/1.1 或 HTTP/2.0。
请求头的字段较多，常使用的包含以下几个：

Host：请求的服务器的域名。

Accept：客户端能够处理的媒体类型。

Accept-Encoding：客户端能够解码的内容编码。

Authorization：用于认证的凭证信息，比如token数据。

Content-Length：请求体的长度。

Content-Type：请求体的媒体类型。

Cookie：存储在客户端的cookie数据。

If-None-Match：资源的ETag值，用于缓存控制。

Connection：管理连接的选项，如 keep-alive。

空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。而请求体通常用于 POST 和 PUT 请求，包含发送给服务器的数据。

（2) 响应报文

HTTP响应报文是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关的数据。一个标准的HTTP响应报文通常包含状态行、响应头、空行、响应体。

状态行包含HTTP版本、状态码和状态消息。例如：HTTP/1.1 200 OK

响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：

Content-Type：指定响应主体的媒体类型。

Content-Length：指定响应主体的长度（字节数）。

Server：指定服务器的信息。

Expires: 响应的过期时间，之后内容被认为是过时的。

ETag: 响应体的实体标签，用于缓存和条件请求。

Last-Modified： 资源最后被修改的日期和时间。

Location：在重定向时指定新的资源位置。

Set-Cookie：在响应中设置Cookie。

Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。

空行（Empty Line）在响应头和响应体之间，表示响应头的结束。而响应体是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可能为空。

#### 3.6任务 HTTP有哪些请求方式？
GET：请求指定的资源。
POST：向指定资源提交数据进行处理请求（例如表单提交）。
PUT：更新指定资源。
DELETE：删除指定资源。
HEAD：获取报文首部，不返回报文主体。
OPTIONS：查询服务器支持的请求方法。
PATCH：对资源进行部分更新。

#### 3.6任务 GET和POST请求的区别
1. 用途：GET请求通常用于获取数据，POST请求用于提交数据。
2. 数据传输：GET请求将参数附加在URL之后，POST请求将数据放在请求体中。
3. 安全性：GET请求由于参数暴露在URL中，安全性较低；POST请求参数不会暴露在URL中，相对更安全。
4. 数据大小：GET请求受到URL长度限制，数据量有限；POST请求理论上没有大小限制。
5. 幂等性：GET请求是幂等的，即多次执行相同的GET请求，资源的状态不会改变；POST请求不是幂等的，因为每次提交都可能改变资源状态。
6. 缓存：GET请求可以被缓存，POST请求默认不会被缓存。


#### 3.7任务 http中常见的状态码
![alt text](images/image-26.png)

#### 3.7任务 什么是强缓存和协商缓存
强缓存和协商缓存是HTTP缓存机制的两种类型，它们用于减少服务器的负担和提高网页加载速度。

强缓存：客户端在没有向服务器发送请求的情况下，直接从本地缓存中获取资源。

1. Expires强缓存：设置一个强缓存时间，此时间范围内，从内存中读取缓存并返回。但是因为Expires判断强缓存过期的机制是获取本地时间戳，与之前拿到的资源文件中的Expires字段的时间做比较来判断是否需要对服务器发起请求。这里有一个巨大的漏洞：“如果我本地时间不准咋办？”所以目前已经被废弃了。
2. Cache-Control强缓存：目前使用的强缓存是通过HTTP响应头中的Cache-Control字段实现，通过max-age来告诉浏览器在指定时间内可以直接使用缓存数据，无需再次请求。


协商缓存：当强缓存失效时，浏览器会发送请求到服务器，通过ETag或Last-Modified等HTTP响应头与服务器进行验证，以确定资源是否被修改。如果资源未修改，服务器返回304 Not Modified状态码，告知浏览器使用本地缓存；如果资源已修改，则返回新的资源，浏览器更新本地缓存。这种方式需要与服务器通信，但可以确保用户总是获取最新的内容。
1. 基于Last-Modified的协商缓存

Last-Modified 是资源的最后修改时间，服务器在响应头部中返回。
当客户端读取到Last-modified的时候，会在下次的请求标头中携带一个字段:If-Modified-Since，而这个请求头中的If-Modified-Since就是服务器第一次修改时候给他的时间
服务器比较请求中的 If-Modified-Since 值与当前资源的 Last-Modified 值，如果比对的结果是没有变化，表示资源未发生变化，返回状态码 304 Not Modified。如果比对的结果说资源已经更新了，就会给浏览器正常返回资源，返回200状态。

但是这样的协商缓存有两个缺点：

因为是更改文件修改时间来判断的，所以在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。
当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会返回新的文件。
2. 基于ETag的协商缓存：将原先协商缓存的比较时间戳的形式修改成了比较文件指纹（根据文件内容计算出的唯一哈希值）。

ETag 是服务器为资源生成的唯一标识符（文件指纹），可以是根据文件内容计算出的哈希值，服务端将其和资源一起放回给客户端。

客户端在请求头部的 If-None-Match 字段中携带上次响应的 ETag 值。

服务器比较请求中的 If-None-Match 值与当前资源的 ETag 值，如果匹配，表示资源未发生变化，返回状态码 304 Not Modified。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端

#### 3.8 任务 HTTP1.1和1.0的区别
持久连接：HTTP/1.1 默认支持持久连接，允许在一个TCP连接上发送多个HTTP请求和响应，减少了连接建立和关闭的开销。而HTTP/1.0 默认为短连接，每次请求都需要建立一个TCP连接，并通过Connection: keep-alive头来实现持久连接。

管道化：HTTP/1.1 支持管道化(不是默认开启)，允许客户端在第一个请求的响应到达之前发送多个请求，这可以减少等待时间，提高效率。HTTP/1.0不支持管道化。

缓存控制：HTTP1.0主要使用If-Modified-Since/Expires来做为缓存判断的标准，而HTTP1.1则引入了更多的缓存控制策略例如Etag / If-None-Match等更多可供选择的缓存头来控制缓存策略。

错误处理：HTTP/1.1 增加了一些新的HTTP状态码，如100 Continue，用于增强错误处理和请求的中间响应。、

Host 头：HTTP/1.1 引入了Host头，允许客户端指定请求的主机名，这使得在同一台服务器上托管多个域名成为可能。HTTP/1.0没有这个头字段。

带宽优化 ：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能， 而HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）

#### 3.8任务 HTTP2.0与HTTP1.1的区别？
1. 二进制协议：HTTP/2.0 采用二进制格式传输数据，而非HTTP/1.1 的文本格式，使得解析更高效，减少了解析时间。
2. 多路复用：HTTP/2.0 支持多路复用，允许在单个TCP连接上并行交错发送多个请求和响应，解决了HTTP/1.1 中的队头阻塞问题。
3. 头部压缩：HTTP/2.0 引入了HPACK 压缩算法，对请求和响应的头部信息进行压缩，减少了冗余头部信息的传输，提高了传输效率。
4. 服务器推送：HTTP/2.0 允许服务器主动推送资源给客户端，而不需要客户端明确请求，这可以减少页面加载时间。
5. 优先级和依赖：HTTP/2.0 允许客户端为请求设置优先级，并表达请求之间的依赖关系，资源加载更加有序。

#### 3.8 任务 https3
HTTP/3是HTTP协议的最新版本，它基于QUIC协议，具有以下特点：

1. 无队头阻塞: QUIC 使用UDP协议来传输数据。一个连接上的多个stream之间没有依赖, 如果一个stream丢了一个UDP包，不会影响后面的stream，不存在 队头阻塞问题。
2. 零 RTT 连接建立：首次连接肯定是需要1 RTT的，0 RTT的优势是在连接的后续建立的 ，从而减少了连接延迟，加快了页面加载速度。
3. 连接迁移：QUIC 允许在网络切换（如从 Wi-Fi 到移动网络）时，将连接迁移到新的 IP 地址，从而减少连接的中断时间。
4. 向前纠错机制：每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传。
5. 安全性：HTTP/3默认使用TLS加密，确保了数据传输的安全性。

#### 3.10 任务 HTTPS和HTTP有哪些区别
https在传输层和应用层之间加上了一个SSL/TLS层，变得更安全了

两者的主要区别在于安全性和数据加密：

1. 加密层：HTTPS 在HTTP 的基础上增加了SSL/TLS 协议作为加密层，确保数据传输的安全性。而HTTP 数据传输是明文的，容易受到攻击。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. 端口：HTTPS 通常使用端口443 ，而HTTP 使用端口80。
4. HTTPS 协议需要向 CA 申请数字证书，来保证服务器的身份是可信的。
   
#### 3.10任务 HTTPS的工作原理(HTTPS建立连接的过程）

HTTPS 主要基于SSL/TLS 协议，确保了数据传输的安全性和完整性, 其建立连接并传输数据的过程如下：

1. 密钥交换：客户端发起HTTPS请求后，服务器会发送其公钥证书给客户端。
2. 证书验证：客户端会验证服务器的证书是否由受信任的证书颁发机构（CA ）签发，并检查证书的有效性。
3. 加密通信：一旦证书验证通过，客户端会生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。
4. 建立安全连接：服务器使用自己的私钥解密得到对称加密密钥，此时客户端和服务器都有了相同的密钥，可以进行加密和解密操作。
5. 数据传输：使用对称加密密钥对所有传输的数据进行加密，确保数据在传输过程中的安全性。
6. 完整性校验：SSL/TLS协议还包括消息完整性校验机制，如消息认证码，确保数据在传输过程中未被篡改。
7. 结束连接：数据传输完成后，通信双方会进行会话密钥的销毁，以确保不会留下安全隐患。

#### 3.10任务 tcp和udp的区别
1. TCP是面向连接的协议，需要在数据传输前建立连接；UDP是无连接的，不需要建立连接。
2. TCP提供可靠的数据传输，保证数据包的顺序和完整性；UDP不保证数据包的顺序或完整性。
3. TCP具有拥塞控制机制，可以根据网络状况调整数据传输速率；UDP没有拥塞控制，发送速率通常固定。
4. TCP通过滑动窗口机制进行流量控制，避免接收方处理不过来；UDP没有流量控制。
5. TCP能够检测并重传丢失或损坏的数据包；UDP不提供错误恢复机制。
6. TCP有复杂的报文头部，包含序列号、确认号等信息；UDP的报文头部相对简单。
7. 由于TCP的连接建立、数据校验和重传机制，其性能开销通常比UDP大；UDP由于简单，性能开销小。
8. 适用场景：TCP适用于需要可靠传输的应用，如网页浏览、文件传输等；UDP适用于对实时性要求高的应用，如语音通话、视频会议等。

## 3.13任务
DNS查询过程
答：收到一个URL，首先向本地DNS缓存查询，然后是本地域名服务器，根域名服务器，顶级域名服务器，权威域名服务器，最后查到一个ip地址返回给本地DNS解析器，把这个地址返回给浏览器，浏览器用这个根服务器建立连接

CDN是什么，有什么作用？

答：CDN是一种分布式网络，将内容存储在分布式服务器上，可以从距离较近的服务器获取所需内容，加入互联网上的内容传输
主要特点是1.就近访问，2.内容缓存

cookie和session是什么
服务器把cookie发给用户浏览器，用户浏览器存下来，到时候访问的时候，服务器根据cookie确定用户身份
session是服务器在自己这里记录的客户端信息，一半每个用户有一个唯一的sessionID记录在cookie种

## 3.19任务

熟悉哪些linux命令
答：文件操作：
ls：列出目录内容。
cd：进入指定目录。
pwd：显示当前工作目录。
cp：复制文件或目录。
mv：移动或重命名文件。
rm：删除文件或目录。
touch：创建空文件或更新文件时间戳。
文件内容查看：
cat：查看文件内容。
head：查看文件的前几行。
tail：查看文件的后几行，常用于查看日志文件。
文件编辑：
vi 或 vim：强大的文本编辑器。
权限管理：
chmod：更改文件或目录的访问权限。
chown：更改文件或目录的所有者和/或所属组。
磁盘管理：
df：查看磁盘空间使用情况。
网络管理：
ifconfig 或 ip addr：查看和配置网络接口。
ping：测试网络连接。
netstat：查看网络状态和统计信息。
ssh：安全远程登录。
进程管理：
ps：查看当前运行的进程。
kill：杀掉某进程。
软件包管理（根据Linux发行版不同，命令可能有所不同）：
apt-get（Debian/Ubuntu）：安装、更新和删除软件包。

**Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用**
答：查看进程： 用 ps 命令查看当前运行的进程，比如 ps aux 可以列出所有进程及其详细信息。
杀死进程： 首先用 ps 或 top 命令找到进程的PID（进程ID）。 然后用 kill 命令加上进程ID来结束进程，例如 kill -9 PID。"-9" 是强制杀死进程的信号。
查看端口占用： 使用 lsof -i:端口号 可以查看占用特定端口的进程。 或者用 netstat -tulnp | grep 端口号，这会显示监听在该端口的服务及其进程ID。

说一下 select、poll、epoll
答：I/O多路复用通常通过select、poll、epoll等系统调用来实现。

select： select是一个最古老的I/O多路复用机制，它可以监视多个文件描述符的可读、可写和错误状态。然而，但是它的效率可能随着监视的文件描述符数量的增加而降低。
poll： poll是select的一种改进，它使用轮询方式来检查多个文件描述符的状态，避免了select中文件描述符数量有限的问题。但对于大量的文件描述符，poll的性能也可能变得不足够高效。
epoll： epoll是Linux特有的I/O多路复用机制，相较于select和poll，它在处理大量文件描述符时更加高效。epoll使用事件通知的方式，只有在文件描述符就绪时才会通知应用程序，而不需要应用程序轮询。
总结：select是最早的 I/O 多路复用技术，但受到文件描述符数量和效率方面的限制。poll克服了文件描述符数量的限制，但仍然存在一定的效率问题。epoll是一种高效的I/O多路复用技术，尤其适用于高并发场景，但它仅在 Linux 平台上可用。一般来说，epoll 的效率是要比 select 和 poll 高的，但是对于活动连接较多的时候，由于回调函数触发的很频繁，其效率不一定比 select 和 poll 高。所以 epoll 在连接数量很多，但活动连接较小的情况性能体现的比较明显。

## day 3.20
一条SQL查询语句是如何执行的？
答：连接器:连接器负责跟客户端建立连接、获取权限、维持和管理连接。
查询缓存: MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value 对的形式，被直接缓存在内存中。
分析器:你输入的是由多个字符串和空格组成的一条SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。
优化器:优化器是在表里面有多个索引的时候，决定使用哪个索引; 或者在一个语句有多表关联(join )的时候，决定各个表的连接顺序。
执行器: MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

事务的四大特性
ACID
A:atomic 原子性，确保事务内的操作要么全部成，要么全部失败回滚
C：consistenty 一致性，事务执行前后，数据库从一个一致性状态转变到另一个一致性状态
I：isolated 隔离性，多个事务并发执行时，每个事务都应该被隔离开来，一个事务的执行不应该影响另一个事务的执行
D: 持久性：事务一旦提交，对数据库的 改变就是永久的，即使系统崩溃或者故障以后也可以保持

数据库的事务隔离级别有哪些
答： 原子 操作，事务、（完全错误）
读未提交：允许一个事务读另一个事务没提交的数据修改，这是最低的隔离等级，有脏读，不可重复读，幻读的问题
读已提交：只有已经提交的数据才让读，解决了脏读，依然存在不可重复读和幻读
可重复读：事务开始和结束期间不能读新数据，解决了不可重复读，依然可能有幻读
序列化：最高等级，事物之间并发执行和串行效果一致
（其实看下来感觉是一样的，读未提交就是原子级的，对应的是操作，事务级的）


## day 3.21
mysql的执行引擎有哪些
执行引擎主要负责查询和执行数据的存储，执行引擎主要有MyISAM，InnoDM,memory等
innodb提供了对事务acid的支持，还提供了行级锁和外键约束，是目前mysql默认的存储引擎，适用于需要事务和高并发的应用
myisam是早期默认的存储引擎，支持全文索引，但是不支持事务，也不支持行级锁和外键约束，适用于快速读取且数据量不大的场景
memort就是放在内存里，访问速度快但是数据在数据库服务器重启后会丢失

MySQL为什么使用B+树来作索引
3.因为b+树可以支持树形查找和顺序索引，可以在半路就查到（不准确）
1是因为b+树树上只存索引不存数据，所以可以每层多存一点索引，，io次数少
2是因为有很多冗余节点，需要删除的时候可以直接删除

B+树是一个B树的变种，提供了高效的数据检索、插入、删除和范围查询性能。

单点查询：B 树进行单个索引查询时，时间代价为O(logn)。从平均时间代价来看，会比 B+ 树稍快一些。但是 B 树的查询波动会比较大，因为每个节点既存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。B+树的非叶子节点不存放实际的记录数据，仅存放索引，所以数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。

插入和删除效率：B+ 树有大量的冗余节点，删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快。B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。B 树没有冗余节点，删除节点的时候非常复杂，可能涉及复杂的树的变形。

范围查询：B+ 树所有叶子节点间有一个链表进行连接，而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如nosql的MongoDB。

索引失效的场景
索引失效意味着查询操作不能有效利用索引进行数据检索，从而导致性能下降，下面一些场景会发生索引失效。

使用OR条件：当使用OR连接多个条件，并且每个条件用到不同的索引列时，索引可能不会被使用。
使用非等值查询：当使用!=或<>操作符时，索引可能不会被使用，特别是当非等值条件在WHERE子句的开始部分时。
对列进行类型转换： 如果在查询中对列进行类型转换，例如将字符列转换为数字或日期，索引可能会失效。
使用LIKE语句：以通配符%开头的LIKE查询会导致索引失效。
函数或表达式：在列上使用函数或表达式作为查询条件，通常会导致索引失效。
表连接中的列类型不匹配： 如果在连接操作中涉及的两个表的列类型不匹配，索引可能会失效。例如，一个表的列是整数，另一个表的列是字符，连接时可能会导致索引失效。

## day3.22
什么是慢查询，什么原因，可以怎么优化

数据库查的很慢，可能是数据量太大，索引不好，数据库设计不好导致冲突了，硬件资源不足，优化：重新设计索引，找到最慢的查询并处理

数据库查询的执行时间超过指定的超时时间时，就被称为慢查询。

原因：

查询语句比较复杂：查询涉及多个表，包含复杂的连接和子查询，可能导致执行时间较长。
查询数据量大：当查询的数据量庞大时，即使查询本身并不复杂，也可能导致较长的执行时间。
缺少索引：如果查询的表没有合适的索引，需要遍历整张表才能找到结果，查询速度较慢。
数据库设计不合理：数据库表设计庞大，查询时可能需要较多时间。
并发冲突：当多个查询同时访问相同的资源时，可能发生并发冲突，导致查询变慢。
硬件资源不足：如果MySQL服务器上同时运行了太多的查询，会导致服务器负载过高，从而导致查询变慢
优化：

运行语句，找到慢查询的sql
查询区分度最高的字段
explain：显示mysql如何使用索引来处理select语句以及连接表，可以帮助选择更好的索引、写出更优化的查询语句
order by limit形式的sql语句，让排序的表优先查
考虑建立索引原则

undo log redo log、binlog 有什么用？
undo log是Innodb存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC。
redo log是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产生一条或者多条物理日志。
binlog (归档日志）是Server 层生成的日志，主要用于数据备份和主从复制。

##day 3.24
mysql和redis的区别
答：Redis基于键值对，支持多种数据结构；而MySQL是一种关系型数据库，使用表来组织数据。
Redis将数据存在内存中，通过持久化机制将数据写入磁盘，MySQL通常将数据存储在磁盘上。
Redis不使用SQL，而是使用自己的命令集，MySQL使用SQL来进行数据查询和操作。
Redis以高性能和低延迟为目标，适用于读多写少的应用场景，MySQL 适用于需要支持复杂查询、事务处理、拥有大规模数据集的场景。
Redis 更适合处理高速、高并发的数据访问，以及需要复杂数据结构和功能的场景，在实际应用中，很多系统会同时使用 MySQL 和 Redis。

redis有什么优缺点，为什么redis查询比较快
答：(1) Redis有什么优缺点？

Redis 是一个基于内存的数据库，读写速度非常快，通常被用作缓存、消息队列、分布式锁和键值存储数据库。它支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等， Redis 还提供了分布式特性，可以将数据分布在多个节点上，以提高可扩展性和可用性。但是Redis 受限于物理内存的大小，不适合存储超大量数据，并且需要大量内存，相比磁盘存储成本更高。

(2）为什么Redis查询快

基于内存操作： 传统的磁盘文件操作相比减少了IO，提高了操作的速度。
高效的数据结构：Redis专门设计了STRING、LIST、HASH等高效的数据结构，依赖各种数据结构提升了读写的效率。
单线程：单线程操作省去了上下文切换带来的开销和CPU的消耗，同时不存在资源竞争，避免了死锁现象的发生。
I/O多路复用：采用I/O多路复用机制同时监听多个Socket，根据Socket上的事件来选择对应的事件处理器进行处理。


## day3.25
redis的数据类型
答：Redis 常见的五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）及 Zset(sorted set：有序集合)。

字符串STRING：存储字符串数据，最基本的数据类型。
哈希表HASH：存储字段和值的映射，用于存储对象。
列表LIST：存储有序的字符串元素列表。
集合SET：存储唯一的字符串元素，无序。
有序集合ZSET：类似于集合，但每个元素都关联一个分数，可以按分数进行排序。
Redis版本更新，又增加了几种数据类型，

BitMap: 存储位的数据结构，可以用于处理一些位运算操作。
HyperLogLog：用于基数估算的数据结构，用于统计元素的唯一数量。
GEO： 存储地理位置信息的数据结构。
Stream：专门为消息队列设计的数据类型。

redis是单线程还是多线程的，为什么
答：Redis在其传统的实现中是单线程的(网络请求模块使用单线程进行处理，其他模块仍用多个线程)，这意味着它使用单个线程来处理所有的客户端请求。这样的设计选择有几个关键原因：

简化模型：单线程模型简化了并发控制，避免了复杂的多线程同步问题。
性能优化：由于大多数操作是内存中的，单线程避免了线程间切换和锁竞争的开销。
原子性保证：单线程执行确保了操作的原子性，简化了事务和持久化的实现。
顺序执行：单线程保证了请求的顺序执行。
但是Redis的单线程模型并不意味着它在处理客户端请求时不高效。实际上，由于其操作主要在内存中进行，Redis能够提供极高的吞吐量和低延迟的响应。

此外，Redis 6.0 引入了多线程的功能，用来处理网络I/O这部分，充分利用CPU资源，减少网络I/O阻塞带来的性能损耗。

redis的持久化机制有哪些
答：AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；
混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；