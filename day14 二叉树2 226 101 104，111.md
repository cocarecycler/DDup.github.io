# day14 二叉树2 226 101 104，111

## 226 翻转二叉树
题目：https://leetcode.cn/problems/invert-binary-tree/description/

递归地把二叉树左中右变成右中左，感觉用递归，每层有一个tmp保存左指针，把右指针交换过去，到左右都为空的时候结束

迭代法的话就是层序遍历之后再输入栈逆序的接回树上

递归方法：
```
void rev(TreeNode* cur)
{
    if(cur->left==nullptr&&cur->right==nullptr)return ;
    TreeNode *tmp=nullptr;//交换过程
    if(cur->left)tmp=cur->left;
        cur->left=cur->right;
    if(tmp!=nullptr)cur->right=tmp;
        //递归处理剩下的
    if(cur->left)rev(cur->left);
    if(cur->right)rev(cur->right);
}
TreeNode* invertTree(TreeNode* root) {
    if(root)rev(root);
    return root;
}
```
会报空指针，把if语句删掉就好了
```
void rev(TreeNode* cur)
    {
        if(cur==nullptr)return ;
        //if(cur->left==nullptr&&cur->right==nullptr)return ;
        TreeNode *tmp=cur->left;//交换过程
        cur->left=cur->right;
        cur->right=tmp;
        //递归处理剩下的
        if(cur->left)rev(cur->left);
        if(cur->right)rev(cur->right);

    }
    TreeNode* invertTree(TreeNode* root) {
        if(root)rev(root);
        return root;
    }
```

迭代方法：用前序或者后续遍历，中序会改变根节点，好像前序后续可以是因为是在遍历过程中改变指针，不需要遍历本身的结果

层序遍历


## 101对称二叉树
题目：

```

```

## 104 二叉树最大深度
题目：

```

```

## 111 二叉树最小深度
题目：

```

```