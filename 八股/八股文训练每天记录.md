## 八股文训练，carl训练营+小林coding redis和数据库

## day1 317
今天训练营的题目补了几天的量，一开始https的都忘干净了，后面3 4 天的都是知识盲区，后面操作系统的主要是进程线程方面的熟悉起来了

### http

#### 3.5任务 tcp/ip和osi的区别
OSI模型， 是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，将计算机网络通信划分为七个不同的层级，每个层级都负责特定的功能。每个层级都构建在其下方的层级之上，并为上方的层级提供服务。七层从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。虽然OSI模型在理论上更全面，但在实际网络通信中，TCP/IP模型更为实用。 TCP/IP模型分为四个层级，每个层级负责特定的网络功能。

1. 应用层：该层与OSI模型的应用层和表示层以及会话层类似，提供直接与用户应用程序交互的接口。它为网络上的各种应用程序提供服务，如电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。
2. 传输层：该层对应OSI模型的传输层。它负责端到端的数据传输，提供可靠的、无连接的数据传输服务。主要的传输层协议有TCP和UDP。TCP提供可靠的数据传输，确保数据的正确性和完整性；而UDP则是无连接的，适用于不要求可靠性的传输，如实时音频和视频流。
3. 网络层：该层对应OSI模型的网络层。主要协议是IP，它负责数据包的路由和转发，选择最佳路径将数据从源主机传输到目标主机。IP协议使用IP地址来标识主机和网络，并进行逻辑地址寻址。
4. 网络接口层：该层对应OSI模型的数据链路层和物理层。它负责物理传输媒介的传输，例如以太网、Wi-Fi等，并提供错误检测和纠正的功能。此外，网络接口层还包含硬件地址（MAC地址）的管理。

osi模型明确定义了服务，协议，接口，tcpip没有，tcpip是对于现有协议的描述，不能迁移到其他协议栈，osi模型没有异构网络的链接，在网络层tcpip只有无连接，osi有有链接和无连接，传输层tcpip有有链接和无连接，osi只有有连接

#### 3.5任务 从输入 URL 到页面展示到底发生了什么？
1. 输入网址，解析URL信息，准备发送HTTP请求

2. 检查浏览器缓存里是否有缓存该资源，如果有直接返回；如果没有进入下一步网络请求。
3. DNS域名解析：网络请求前，进行DNS解析，以获取请求域名的IP地址。DNS解析时会按本地浏览器缓存->本地Host文件->路由器缓存->DNS服务器->根DNS服务器的顺序查询域名对应IP，直到找到为止。
4. TCP三次握手建立连接：浏览器与服务器IP建立TCP连接。
5. 客户端发送HTTP请求：连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。如果是HTTPS的话，还涉及到HTTPS的加解密流程。
6. 服务器处理请求并返回HTTP资源：服务器接收到请求信息，根据请求生成响应数据。
7. TCP四次挥手断开连接：浏览器与服务器IP断开TCP连接。
8. 浏览器解析响应并渲染页面：
    
    浏览器解析响应头。若响应头状态码为301、302，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部渲染流程。

    浏览器解析HTML文件，创建DOM树，解析CSS进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成页面展示。

#### 3.6 任务HTTP请求报文和响应报文是怎样的，有哪些常见的字段

HTTP报文分为请求报文和响应报文。

（1） 请求报文 请求报文主要由请求行、请求头、空行、请求体构成。 请求行包括如下字段：

方法（Method）：指定要执行的操作，如 GET、POST、PUT、DELETE 等。
资源路径（Resource Path）：请求的资源的URI（统一资源标识符）。
HTTP版本（HTTP Version）：使用的HTTP协议版本，如 HTTP/1.1 或 HTTP/2.0。
请求头的字段较多，常使用的包含以下几个：

Host：请求的服务器的域名。

Accept：客户端能够处理的媒体类型。

Accept-Encoding：客户端能够解码的内容编码。

Authorization：用于认证的凭证信息，比如token数据。

Content-Length：请求体的长度。

Content-Type：请求体的媒体类型。

Cookie：存储在客户端的cookie数据。

If-None-Match：资源的ETag值，用于缓存控制。

Connection：管理连接的选项，如 keep-alive。

空行是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。而请求体通常用于 POST 和 PUT 请求，包含发送给服务器的数据。

（2) 响应报文

HTTP响应报文是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关的数据。一个标准的HTTP响应报文通常包含状态行、响应头、空行、响应体。

状态行包含HTTP版本、状态码和状态消息。例如：HTTP/1.1 200 OK

响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：

Content-Type：指定响应主体的媒体类型。

Content-Length：指定响应主体的长度（字节数）。

Server：指定服务器的信息。

Expires: 响应的过期时间，之后内容被认为是过时的。

ETag: 响应体的实体标签，用于缓存和条件请求。

Last-Modified： 资源最后被修改的日期和时间。

Location：在重定向时指定新的资源位置。

Set-Cookie：在响应中设置Cookie。

Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。

空行（Empty Line）在响应头和响应体之间，表示响应头的结束。而响应体是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可能为空。

#### 3.6任务 HTTP有哪些请求方式？
GET：请求指定的资源。
POST：向指定资源提交数据进行处理请求（例如表单提交）。
PUT：更新指定资源。
DELETE：删除指定资源。
HEAD：获取报文首部，不返回报文主体。
OPTIONS：查询服务器支持的请求方法。
PATCH：对资源进行部分更新。

#### 3.6任务 GET和POST请求的区别
1. 用途：GET请求通常用于获取数据，POST请求用于提交数据。
2. 数据传输：GET请求将参数附加在URL之后，POST请求将数据放在请求体中。
3. 安全性：GET请求由于参数暴露在URL中，安全性较低；POST请求参数不会暴露在URL中，相对更安全。
4. 数据大小：GET请求受到URL长度限制，数据量有限；POST请求理论上没有大小限制。
5. 幂等性：GET请求是幂等的，即多次执行相同的GET请求，资源的状态不会改变；POST请求不是幂等的，因为每次提交都可能改变资源状态。
6. 缓存：GET请求可以被缓存，POST请求默认不会被缓存。


#### 3.7任务 http中常见的状态码
![alt text](images/image-26.png)

#### 3.7任务 什么是强缓存和协商缓存
强缓存和协商缓存是HTTP缓存机制的两种类型，它们用于减少服务器的负担和提高网页加载速度。

强缓存：客户端在没有向服务器发送请求的情况下，直接从本地缓存中获取资源。

1. Expires强缓存：设置一个强缓存时间，此时间范围内，从内存中读取缓存并返回。但是因为Expires判断强缓存过期的机制是获取本地时间戳，与之前拿到的资源文件中的Expires字段的时间做比较来判断是否需要对服务器发起请求。这里有一个巨大的漏洞：“如果我本地时间不准咋办？”所以目前已经被废弃了。
2. Cache-Control强缓存：目前使用的强缓存是通过HTTP响应头中的Cache-Control字段实现，通过max-age来告诉浏览器在指定时间内可以直接使用缓存数据，无需再次请求。


协商缓存：当强缓存失效时，浏览器会发送请求到服务器，通过ETag或Last-Modified等HTTP响应头与服务器进行验证，以确定资源是否被修改。如果资源未修改，服务器返回304 Not Modified状态码，告知浏览器使用本地缓存；如果资源已修改，则返回新的资源，浏览器更新本地缓存。这种方式需要与服务器通信，但可以确保用户总是获取最新的内容。
1. 基于Last-Modified的协商缓存

Last-Modified 是资源的最后修改时间，服务器在响应头部中返回。
当客户端读取到Last-modified的时候，会在下次的请求标头中携带一个字段:If-Modified-Since，而这个请求头中的If-Modified-Since就是服务器第一次修改时候给他的时间
服务器比较请求中的 If-Modified-Since 值与当前资源的 Last-Modified 值，如果比对的结果是没有变化，表示资源未发生变化，返回状态码 304 Not Modified。如果比对的结果说资源已经更新了，就会给浏览器正常返回资源，返回200状态。

但是这样的协商缓存有两个缺点：

因为是更改文件修改时间来判断的，所以在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。
当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会返回新的文件。
2. 基于ETag的协商缓存：将原先协商缓存的比较时间戳的形式修改成了比较文件指纹（根据文件内容计算出的唯一哈希值）。

ETag 是服务器为资源生成的唯一标识符（文件指纹），可以是根据文件内容计算出的哈希值，服务端将其和资源一起放回给客户端。

客户端在请求头部的 If-None-Match 字段中携带上次响应的 ETag 值。

服务器比较请求中的 If-None-Match 值与当前资源的 ETag 值，如果匹配，表示资源未发生变化，返回状态码 304 Not Modified。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端

#### 3.8 任务 HTTP1.1和1.0的区别
持久连接：HTTP/1.1 默认支持持久连接，允许在一个TCP连接上发送多个HTTP请求和响应，减少了连接建立和关闭的开销。而HTTP/1.0 默认为短连接，每次请求都需要建立一个TCP连接，并通过Connection: keep-alive头来实现持久连接。

管道化：HTTP/1.1 支持管道化(不是默认开启)，允许客户端在第一个请求的响应到达之前发送多个请求，这可以减少等待时间，提高效率。HTTP/1.0不支持管道化。

缓存控制：HTTP1.0主要使用If-Modified-Since/Expires来做为缓存判断的标准，而HTTP1.1则引入了更多的缓存控制策略例如Etag / If-None-Match等更多可供选择的缓存头来控制缓存策略。

错误处理：HTTP/1.1 增加了一些新的HTTP状态码，如100 Continue，用于增强错误处理和请求的中间响应。、

Host 头：HTTP/1.1 引入了Host头，允许客户端指定请求的主机名，这使得在同一台服务器上托管多个域名成为可能。HTTP/1.0没有这个头字段。

带宽优化 ：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能， 而HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）

#### 3.8任务 HTTP2.0与HTTP1.1的区别？
1. 二进制协议：HTTP/2.0 采用二进制格式传输数据，而非HTTP/1.1 的文本格式，使得解析更高效，减少了解析时间。
2. 多路复用：HTTP/2.0 支持多路复用，允许在单个TCP连接上并行交错发送多个请求和响应，解决了HTTP/1.1 中的队头阻塞问题。
3. 头部压缩：HTTP/2.0 引入了HPACK 压缩算法，对请求和响应的头部信息进行压缩，减少了冗余头部信息的传输，提高了传输效率。
4. 服务器推送：HTTP/2.0 允许服务器主动推送资源给客户端，而不需要客户端明确请求，这可以减少页面加载时间。
5. 优先级和依赖：HTTP/2.0 允许客户端为请求设置优先级，并表达请求之间的依赖关系，资源加载更加有序。

#### 3.8 任务 https3
HTTP/3是HTTP协议的最新版本，它基于QUIC协议，具有以下特点：

1. 无队头阻塞: QUIC 使用UDP协议来传输数据。一个连接上的多个stream之间没有依赖, 如果一个stream丢了一个UDP包，不会影响后面的stream，不存在 队头阻塞问题。
2. 零 RTT 连接建立：首次连接肯定是需要1 RTT的，0 RTT的优势是在连接的后续建立的 ，从而减少了连接延迟，加快了页面加载速度。
3. 连接迁移：QUIC 允许在网络切换（如从 Wi-Fi 到移动网络）时，将连接迁移到新的 IP 地址，从而减少连接的中断时间。
4. 向前纠错机制：每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传。
5. 安全性：HTTP/3默认使用TLS加密，确保了数据传输的安全性。

#### 3.10 任务 HTTPS和HTTP有哪些区别
https在传输层和应用层之间加上了一个SSL/TLS层，变得更安全了

两者的主要区别在于安全性和数据加密：

1. 加密层：HTTPS 在HTTP 的基础上增加了SSL/TLS 协议作为加密层，确保数据传输的安全性。而HTTP 数据传输是明文的，容易受到攻击。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. 端口：HTTPS 通常使用端口443 ，而HTTP 使用端口80。
4. HTTPS 协议需要向 CA 申请数字证书，来保证服务器的身份是可信的。
   
#### 3.10任务 HTTPS的工作原理(HTTPS建立连接的过程）

HTTPS 主要基于SSL/TLS 协议，确保了数据传输的安全性和完整性, 其建立连接并传输数据的过程如下：

1. 密钥交换：客户端发起HTTPS请求后，服务器会发送其公钥证书给客户端。
2. 证书验证：客户端会验证服务器的证书是否由受信任的证书颁发机构（CA ）签发，并检查证书的有效性。
3. 加密通信：一旦证书验证通过，客户端会生成一个随机的对称加密密钥，并使用服务器的公钥加密这个密钥，然后发送给服务器。
4. 建立安全连接：服务器使用自己的私钥解密得到对称加密密钥，此时客户端和服务器都有了相同的密钥，可以进行加密和解密操作。
5. 数据传输：使用对称加密密钥对所有传输的数据进行加密，确保数据在传输过程中的安全性。
6. 完整性校验：SSL/TLS协议还包括消息完整性校验机制，如消息认证码，确保数据在传输过程中未被篡改。
7. 结束连接：数据传输完成后，通信双方会进行会话密钥的销毁，以确保不会留下安全隐患。

#### 3.10任务 tcp和udp的区别
1. TCP是面向连接的协议，需要在数据传输前建立连接；UDP是无连接的，不需要建立连接。
2. TCP提供可靠的数据传输，保证数据包的顺序和完整性；UDP不保证数据包的顺序或完整性。
3. TCP具有拥塞控制机制，可以根据网络状况调整数据传输速率；UDP没有拥塞控制，发送速率通常固定。
4. TCP通过滑动窗口机制进行流量控制，避免接收方处理不过来；UDP没有流量控制。
5. TCP能够检测并重传丢失或损坏的数据包；UDP不提供错误恢复机制。
6. TCP有复杂的报文头部，包含序列号、确认号等信息；UDP的报文头部相对简单。
7. 由于TCP的连接建立、数据校验和重传机制，其性能开销通常比UDP大；UDP由于简单，性能开销小。
8. 适用场景：TCP适用于需要可靠传输的应用，如网页浏览、文件传输等；UDP适用于对实时性要求高的应用，如语音通话、视频会议等。

## 3.13任务
DNS查询过程
答：收到一个URL，首先向本地DNS缓存查询，然后是本地域名服务器，根域名服务器，顶级域名服务器，权威域名服务器，最后查到一个ip地址返回给本地DNS解析器，把这个地址返回给浏览器，浏览器用这个根服务器建立连接

CDN是什么，有什么作用？

答：CDN是一种分布式网络，将内容存储在分布式服务器上，可以从距离较近的服务器获取所需内容，加入互联网上的内容传输
主要特点是1.就近访问，2.内容缓存

cookie和session是什么
服务器把cookie发给用户浏览器，用户浏览器存下来，到时候访问的时候，服务器根据cookie确定用户身份
session是服务器在自己这里记录的客户端信息，一半每个用户有一个唯一的sessionID记录在cookie种

## 3.19任务

熟悉哪些linux命令
答：文件操作：
ls：列出目录内容。
cd：进入指定目录。
pwd：显示当前工作目录。
cp：复制文件或目录。
mv：移动或重命名文件。
rm：删除文件或目录。
touch：创建空文件或更新文件时间戳。
文件内容查看：
cat：查看文件内容。
head：查看文件的前几行。
tail：查看文件的后几行，常用于查看日志文件。
文件编辑：
vi 或 vim：强大的文本编辑器。
权限管理：
chmod：更改文件或目录的访问权限。
chown：更改文件或目录的所有者和/或所属组。
磁盘管理：
df：查看磁盘空间使用情况。
网络管理：
ifconfig 或 ip addr：查看和配置网络接口。
ping：测试网络连接。
netstat：查看网络状态和统计信息。
ssh：安全远程登录。
进程管理：
ps：查看当前运行的进程。
kill：杀掉某进程。
软件包管理（根据Linux发行版不同，命令可能有所不同）：
apt-get（Debian/Ubuntu）：安装、更新和删除软件包。

**Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用**
答：查看进程： 用 ps 命令查看当前运行的进程，比如 ps aux 可以列出所有进程及其详细信息。
杀死进程： 首先用 ps 或 top 命令找到进程的PID（进程ID）。 然后用 kill 命令加上进程ID来结束进程，例如 kill -9 PID。"-9" 是强制杀死进程的信号。
查看端口占用： 使用 lsof -i:端口号 可以查看占用特定端口的进程。 或者用 netstat -tulnp | grep 端口号，这会显示监听在该端口的服务及其进程ID。

说一下 select、poll、epoll
答：I/O多路复用通常通过select、poll、epoll等系统调用来实现。

select： select是一个最古老的I/O多路复用机制，它可以监视多个文件描述符的可读、可写和错误状态。然而，但是它的效率可能随着监视的文件描述符数量的增加而降低。
poll： poll是select的一种改进，它使用轮询方式来检查多个文件描述符的状态，避免了select中文件描述符数量有限的问题。但对于大量的文件描述符，poll的性能也可能变得不足够高效。
epoll： epoll是Linux特有的I/O多路复用机制，相较于select和poll，它在处理大量文件描述符时更加高效。epoll使用事件通知的方式，只有在文件描述符就绪时才会通知应用程序，而不需要应用程序轮询。
总结：select是最早的 I/O 多路复用技术，但受到文件描述符数量和效率方面的限制。poll克服了文件描述符数量的限制，但仍然存在一定的效率问题。epoll是一种高效的I/O多路复用技术，尤其适用于高并发场景，但它仅在 Linux 平台上可用。一般来说，epoll 的效率是要比 select 和 poll 高的，但是对于活动连接较多的时候，由于回调函数触发的很频繁，其效率不一定比 select 和 poll 高。所以 epoll 在连接数量很多，但活动连接较小的情况性能体现的比较明显。

## day 3.20
一条SQL查询语句是如何执行的？
答：连接器:连接器负责跟客户端建立连接、获取权限、维持和管理连接。
查询缓存: MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value 对的形式，被直接缓存在内存中。
分析器:你输入的是由多个字符串和空格组成的一条SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。
优化器:优化器是在表里面有多个索引的时候，决定使用哪个索引; 或者在一个语句有多表关联(join )的时候，决定各个表的连接顺序。
执行器: MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

事务的四大特性
ACID
A:atomic 原子性，确保事务内的操作要么全部成，要么全部失败回滚
C：consistenty 一致性，事务执行前后，数据库从一个一致性状态转变到另一个一致性状态
I：isolated 隔离性，多个事务并发执行时，每个事务都应该被隔离开来，一个事务的执行不应该影响另一个事务的执行
D: 持久性：事务一旦提交，对数据库的 改变就是永久的，即使系统崩溃或者故障以后也可以保持

数据库的事务隔离级别有哪些
答： 原子 操作，事务、（完全错误）
读未提交：允许一个事务读另一个事务没提交的数据修改，这是最低的隔离等级，有脏读，不可重复读，幻读的问题
读已提交：只有已经提交的数据才让读，解决了脏读，依然存在不可重复读和幻读
可重复读：事务开始和结束期间不能读新数据，解决了不可重复读，依然可能有幻读
序列化：最高等级，事物之间并发执行和串行效果一致
（其实看下来感觉是一样的，读未提交就是原子级的，对应的是操作，事务级的）


## day 3.21
mysql的执行引擎有哪些
执行引擎主要负责查询和执行数据的存储，执行引擎主要有MyISAM，InnoDM,memory等
innodb提供了对事务acid的支持，还提供了行级锁和外键约束，是目前mysql默认的存储引擎，适用于需要事务和高并发的应用
myisam是早期默认的存储引擎，支持全文索引，但是不支持事务，也不支持行级锁和外键约束，适用于快速读取且数据量不大的场景
memort就是放在内存里，访问速度快但是数据在数据库服务器重启后会丢失

MySQL为什么使用B+树来作索引
3.因为b+树可以支持树形查找和顺序索引，可以在半路就查到（不准确）
1是因为b+树树上只存索引不存数据，所以可以每层多存一点索引，，io次数少
2是因为有很多冗余节点，需要删除的时候可以直接删除

B+树是一个B树的变种，提供了高效的数据检索、插入、删除和范围查询性能。

单点查询：B 树进行单个索引查询时，时间代价为O(logn)。从平均时间代价来看，会比 B+ 树稍快一些。但是 B 树的查询波动会比较大，因为每个节点既存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。B+树的非叶子节点不存放实际的记录数据，仅存放索引，所以数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。

插入和删除效率：B+ 树有大量的冗余节点，删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快。B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。B 树没有冗余节点，删除节点的时候非常复杂，可能涉及复杂的树的变形。

范围查询：B+ 树所有叶子节点间有一个链表进行连接，而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如nosql的MongoDB。

索引失效的场景
索引失效意味着查询操作不能有效利用索引进行数据检索，从而导致性能下降，下面一些场景会发生索引失效。

使用OR条件：当使用OR连接多个条件，并且每个条件用到不同的索引列时，索引可能不会被使用。
使用非等值查询：当使用!=或<>操作符时，索引可能不会被使用，特别是当非等值条件在WHERE子句的开始部分时。
对列进行类型转换： 如果在查询中对列进行类型转换，例如将字符列转换为数字或日期，索引可能会失效。
使用LIKE语句：以通配符%开头的LIKE查询会导致索引失效。
函数或表达式：在列上使用函数或表达式作为查询条件，通常会导致索引失效。
表连接中的列类型不匹配： 如果在连接操作中涉及的两个表的列类型不匹配，索引可能会失效。例如，一个表的列是整数，另一个表的列是字符，连接时可能会导致索引失效。

## day3.22
什么是慢查询，什么原因，可以怎么优化

数据库查的很慢，可能是数据量太大，索引不好，数据库设计不好导致冲突了，硬件资源不足，优化：重新设计索引，找到最慢的查询并处理

数据库查询的执行时间超过指定的超时时间时，就被称为慢查询。

原因：

查询语句比较复杂：查询涉及多个表，包含复杂的连接和子查询，可能导致执行时间较长。
查询数据量大：当查询的数据量庞大时，即使查询本身并不复杂，也可能导致较长的执行时间。
缺少索引：如果查询的表没有合适的索引，需要遍历整张表才能找到结果，查询速度较慢。
数据库设计不合理：数据库表设计庞大，查询时可能需要较多时间。
并发冲突：当多个查询同时访问相同的资源时，可能发生并发冲突，导致查询变慢。
硬件资源不足：如果MySQL服务器上同时运行了太多的查询，会导致服务器负载过高，从而导致查询变慢
优化：

运行语句，找到慢查询的sql
查询区分度最高的字段
explain：显示mysql如何使用索引来处理select语句以及连接表，可以帮助选择更好的索引、写出更优化的查询语句
order by limit形式的sql语句，让排序的表优先查
考虑建立索引原则

undo log redo log、binlog 有什么用？
undo log是Innodb存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC。
redo log是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产生一条或者多条物理日志。
binlog (归档日志）是Server 层生成的日志，主要用于数据备份和主从复制。

##day 3.24
mysql和redis的区别
答：Redis基于键值对，支持多种数据结构；而MySQL是一种关系型数据库，使用表来组织数据。
Redis将数据存在内存中，通过持久化机制将数据写入磁盘，MySQL通常将数据存储在磁盘上。
Redis不使用SQL，而是使用自己的命令集，MySQL使用SQL来进行数据查询和操作。
Redis以高性能和低延迟为目标，适用于读多写少的应用场景，MySQL 适用于需要支持复杂查询、事务处理、拥有大规模数据集的场景。
Redis 更适合处理高速、高并发的数据访问，以及需要复杂数据结构和功能的场景，在实际应用中，很多系统会同时使用 MySQL 和 Redis。

redis有什么优缺点，为什么redis查询比较快
答：(1) Redis有什么优缺点？

Redis 是一个基于内存的数据库，读写速度非常快，通常被用作缓存、消息队列、分布式锁和键值存储数据库。它支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等， Redis 还提供了分布式特性，可以将数据分布在多个节点上，以提高可扩展性和可用性。但是Redis 受限于物理内存的大小，不适合存储超大量数据，并且需要大量内存，相比磁盘存储成本更高。

(2）为什么Redis查询快

基于内存操作： 传统的磁盘文件操作相比减少了IO，提高了操作的速度。
高效的数据结构：Redis专门设计了STRING、LIST、HASH等高效的数据结构，依赖各种数据结构提升了读写的效率。
单线程：单线程操作省去了上下文切换带来的开销和CPU的消耗，同时不存在资源竞争，避免了死锁现象的发生。
I/O多路复用：采用I/O多路复用机制同时监听多个Socket，根据Socket上的事件来选择对应的事件处理器进行处理。


## day3.25
redis的数据类型
答：Redis 常见的五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）及 Zset(sorted set：有序集合)。

字符串STRING：存储字符串数据，最基本的数据类型。
哈希表HASH：存储字段和值的映射，用于存储对象。
列表LIST：存储有序的字符串元素列表。
集合SET：存储唯一的字符串元素，无序。
有序集合ZSET：类似于集合，但每个元素都关联一个分数，可以按分数进行排序。
Redis版本更新，又增加了几种数据类型，

BitMap: 存储位的数据结构，可以用于处理一些位运算操作。
HyperLogLog：用于基数估算的数据结构，用于统计元素的唯一数量。
GEO： 存储地理位置信息的数据结构。
Stream：专门为消息队列设计的数据类型。

redis是单线程还是多线程的，为什么
答：Redis在其传统的实现中是单线程的(网络请求模块使用单线程进行处理，其他模块仍用多个线程)，这意味着它使用单个线程来处理所有的客户端请求。这样的设计选择有几个关键原因：

简化模型：单线程模型简化了并发控制，避免了复杂的多线程同步问题。
性能优化：由于大多数操作是内存中的，单线程避免了线程间切换和锁竞争的开销。
原子性保证：单线程执行确保了操作的原子性，简化了事务和持久化的实现。
顺序执行：单线程保证了请求的顺序执行。
但是Redis的单线程模型并不意味着它在处理客户端请求时不高效。实际上，由于其操作主要在内存中进行，Redis能够提供极高的吞吐量和低延迟的响应。

此外，Redis 6.0 引入了多线程的功能，用来处理网络I/O这部分，充分利用CPU资源，减少网络I/O阻塞带来的性能损耗。

redis的持久化机制有哪些
答：AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；
混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；


## day3.26
redis缓存雪崩和缓存穿透，如何解决
答：
缓存雪崩是指在某个时间点，大量缓存同时失效，导致请求直接访问数据库或者其他后端系统，解决方法:设置合理过期时间，或者永不过期但是定期更新缓存

缓存击穿是指一个缓存中不在但是数据库中存在的情况，有大量请求同时访问这个数据导致系统负载增加，解决方法是设置互斥锁，或者在查询数据库之前检查一下有没有这个数据

缓存穿透:这个数据缓存和数据库都没在；布隆过滤器过滤恶意请求或者在查询前先进性参数的合法性检验

如何保证数据库和缓存一致性
答
Cache Aside

原理：先从缓存中读取数据，如果没有就再去数据库里面读数据，然后把数据放回缓存中，如果缓存中可以找到数据就直接返回数据；更新数据的时候先把数据持久化到数据库，然后再让缓存失效。
问题：假如有两个操作一个更新一个查询，第一个操作先更新数据库，还没来及删除缓存，查询操作可能拿到的就是旧的数据；更新操作马上让缓存失效了，所以后续的查询可以保证数据的一致性；还有的问题就是有一个是读操作没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，也会造成脏数据。
可行性：出现上述问题的概率其实非常低，需要同时达成读缓存时缓存失效并且有并发写的操作。数据库读写要比缓存慢得多，所以读操作在写操作之前进入数据库，并且在写操作之后更新，概率比较低。
Read/Write Through

原理：Read/Write Through原理是把更新数据库（Repository）的操作由缓存代理，应用认为后端是一个单一的存储，而存储自己维护自己的缓存。
Read Through：就是在查询操作中更新缓存，也就是说，当缓存失效的时候，Cache Aside策略是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对调用方是透明的。
Write Through：当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由缓存自己更新数据库（这是一个同步操作）。
Write Behind

原理：在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作非常快，带来的问题是，数据不是强一致性的，而且可能会丢。
第二步失效问题：这种可能性极小，缓存删除只是标记一下无效的软删除，可以看作不耗时间。如果会出问题，一般程序在写数据库那里就没有完成：故意在写完数据库后，休眠很长时间再来删除缓存。

## day3.27
c++内存分区
答
有堆，栈，全局/静态存储区，常量段，代码段

很多情况下，提到 C++ 程序的内存分区时，会简化为下面五个主要区域

栈（Stack）: 用于存储局部变量和函数调用的上下文。栈的内存分配是自动的，由编译器管理。

堆（Heap）: 用于动态内存分配。程序员可以使用 new、malloc 等操作符或函数从堆上分配内存，并使用 delete、free 释放内存。

全局/静态存储区（Global/Static Storage）: 存储全局变量和静态变量，包括：

数据段：存储初始化的全局变量和静态变量。
BSS 段 ：存储未初始化的全局变量和静态变量。
常量存储区（Constant Data）: 存储程序中的常量数据，如字符串字面量。

代码段（Code Segment 或 Text Segment）: 存储程序的可执行代码和函数的二进制指令。

## day3.28
static关键字和const关键字的作用
答
static和const是C++ 中两个常用的关键字, 有以下作用：

static 关键字: 用于控制变量和函数的生命周期、作用域和访问权限。

声明静态变量：静态变量的生命周期直到程序结束。当在函数内部声明静态变量时，即使函数执行完了也不会释放它，下次调用该函数时会保留上次的状态。
在类中，被static声明的成员被称为静态成员。
静态成员变量：在类中使用static关键字修饰的成员变量，表示该变量属于类而不是类的实例，所有实例共享同一份数据
静态成员函数：在类内使用static关键字修饰的成员函数，所有对象共享同一个函数；静态成员函数只能访问静态成员变量；静态成员函数调用可以不需要通过创建类的实例，而是直接通过类名调用。
static变量如果被多个线程访问，需要特别注意线程安全问题。
const: 关键字用于定义常量，即一旦初始化后其值不能被修改：

常量变量：声明变量，使变量的值不能修改（只读）
常量成员函数，表示该函数不会修改对象的成员变量
常量指针：可以指向一个 const 类型的值，或者是一个指向 const 值的指针，表明指针指向的值不能通过这个指针被修改。
const变量由于其不可变性，天然具有线程安全性。
有时候static和const 可以组合使用，如static const变量，表示一个静态的常量。

总结来说，static关键字用于创建类的静态成员，而const 关键字用于定义常量。

## day3.29
智能指针的实现原理是什么（感觉就是linux文件指针的里面的软硬连接的原理）
答：std::unique_ptr

unique_ptr代表独占所有权的智能指针，同一时间只能有一个unique_ptr实例指向特定资源。
它通过析构函数来管理资源的释放。当unique_ptr超出作用域时，会自动调用删除操作符来释放其指向的内存。
std::unique_ptr 通过删除复制构造函数和复制赋值运算符来确保所有权的唯一性，但提供移动构造函数和移动赋值运算符，允许所有权的转移。
std::shared_ptr

shared_ptr允许多个指针实例共享对同一资源的所有权，使用引用计数机制来跟踪有多少个shared_ptr指向同一资源。
内部维护一个控制块，通常包含引用计数和资源的原始指针。每当创建一个新的shared_ptr或将一个shared_ptr赋值给另一个时，引用计数增加。
当shared_ptr被销毁或通过标准库提供的reset成员函数重置时，引用计数减少。当引用计数降到零时，控制块会释放资源并自我销毁。
std::weak_ptr

std::weak_ptr 是一种不拥有对象的智能指针，它观察 std::shared_ptr 管理的对象，但不增加引用计数。

它用于解决 std::shared_ptr 之间可能产生的循环引用问题，因为循环引用会导致引用计数永远不会达到零，从而造成内存泄漏。

## day3.31
malloc和new有什么区别
答：new是分配新内存，不需要手动析构，类型安全，是一个操作符不是函数


new和malloc在C++中都用于动态内存分配，但它们之间有几个关键的区别：

语法层面：
new是C++的操作符，可以直接用来分配对象或数组。
malloc是一个函数，通常需要包含头文件<cstdlib>，并且只分配原始内存。
类型安全：
new是类型安全的，它会根据分配的对象类型进行正确的内存分配和构造函数调用。
malloc 不是类型安全的，它只分配原始内存，不调用构造函数。返回类型是 void*，需要强制类型转换为具体的指针类型。
构造与析构：
使用 new 分配的对象在对象生命周期结束时需要使用 delete 来释放，delete 会自动调用对象的析构函数。
使用 malloc 分配的内存需要使用 free 来释放，free 不会自动调用析构函数，因此如果分配的是对象数组，需要手动调用析构函数。
异常安全性：
new在分配失败时会抛出std::bad_alloc异常。
malloc在分配失败时返回NULL指针。
管理机制：
C++中的new和delete通常由编译器实现，可能包含一些额外的内存管理机制。
C语言的malloc和free由C标准库提供，与编译器无关。
总结来说，new和malloc都是动态内存分配的手段，但new提供了类型安全和构造/析构的自动化，而malloc则提供了更底层的内存分配方式，需要手动管理构造和析构。在C++中，推荐使用new来分配对象，以保持类型安全和自动化的资源管理。

delete和free有什么区别（对应new和malloc）
答：
delete和free都是用来释放动态分配的内存，但它们有不同的使用方式：

语法：

delete是C++中的关键字，用于释放由new分配的对象。
free是C语言中的函数，通常包含在<stdlib.h>头文件中，用于释放由malloc分配的内存。
对象销毁：

当使用 delete 释放对象内存时，C++  编译器会自动调用对象的析构函数，释放与对象相关的资源，并执行对象的清理工作。
free 仅释放内存，不调用析构函数。因此，如果使用 malloc 分配了 C++ 对象的内存，需要手动调用析构函数后再调用 free。
数组处理：

如果是数组，C++提供了delete[]来释放整个数组的内存，而C语言中仍然使用free，没有区分单个对象和数组。
返回值:

free 没有返回值，即使内存释放失败，也不会反馈任何信息。

delete 之后，指针会自动置为 nullptr

类型检查:

delete 进行类型检查，确保删除的对象类型与 new 分配时的类型一致。

free 不进行类型检查，因为它只处理 void* 类型的指针。

总结来说，delete和free都是用来释放动态内存的，但它们分别用于C++和C语言中的内存管理。delete适用于C++对象，会自动调用析构函数；而free适用于C语言分配的内存，不涉及对象的析构。


堆区和栈区的区别
答：栈区是自动管理的，释放速度很快，主要用于存函数参数，局部变量等，堆区用来存malloc临时分哦欸的值

堆 （Heap） 和栈 （Stack） 是程序运行时两种不同的内存分配区域

内存分配：

栈
是由编译器自动管理的，用于存储局部变量和函数调用的上下文信息。
栈上的对象在定义它们的块或函数调用结束后自动销毁。
栈的内存分配和释放速度很快，因为栈的内存管理是连续的，不需要搜索空闲内存。
堆
由程序员手动管理的，用于存储动态分配的对象。
堆上的对象需要程序员手动释放，否则可能导致内存泄漏。
堆的内存分配和释放速度通常比栈慢，因为可能需要搜索合适的内存块，并且涉及内存碎片整理。
大小限制：

栈的大小通常有限制，远小于堆的大小，且在不同系统和编译器中可能不同。
堆的大小通常很大，受限于系统可用内存。
使用场景：

栈主要用于存储函数参数、局部变量等。
堆用于存储生存期不受限于单个函数调用的对象，如使用 new 或 malloc 分配的对象。

## 4.1
什么是内存泄漏，如何检测和防止
打开什么东西忘记关了

**如果程序的某一段代码在内存池中动态申请了一块内存而没有及时将其释放，就会导致那块内存一直处于被占用的状态而无法使用，造成了资源的浪费。**内存泄漏并不是说物理上的消失掉了，是因为无法使用该区域，在外界看来这块内存就好像被泄漏了一样。

什么操作会导致内存泄漏

忘记释放内存：使用 new 或 malloc 等分配内存后，没有使用 delete 或 free 释放内存。
子类继承父类时，没有将基类的析构函数定义为虚函数。
野指针：指针被赋值为 nullptr 或重新赋值后，丢失了对先前分配内存的引用，导致无法释放。
循环引用：在使用引用计数的智能指针（如 std::shared_ptr）时，循环引用会导致引用计数永远不会归零，从而无法释放内存。
使用不匹配的内存释放函数: 使用 delete 释放由 new[] 分配的内存，或使用 delete[] 释放由 new 分配的内存，这可能导致未定义行为。
资源未关闭：对于文件、网络连接等资源，如果没有正确关闭，虽然不直接导致内存泄漏，但会占用系统资源，可能导致资源耗尽。
如何检测：使用工具如Valgrind、AddressSanitizer或Visual Studio的诊断工具来检测内存泄漏。

如何避免

使用智能指针:优先使用 std::unique_ptr、std::shared_ptr 等智能指针来自动管理内存。

确保资源释放: 对于手动分配的内存，确保在不再需要时使用 delete 或 free 释放。

内存泄漏检测工具: 在开发和测试阶段，定期使用内存泄漏检测工具检查程序。

什么是野指针 如何避免
答：
什么是野指针

野指针是指“指向已经被释放的或无效的内存地址的指针”。在 C 和 C++ 这类允许直接操作内存地址的语言中，如果指针没有被正确初始化，或者指针所指向的内存已经被释放，那么这个指针就成为了野指针。使用野指针可能会导致程序崩溃、数据损坏或者其他一些不可预测的行为。

在什么情况下会产生野指针？

在释放后没有置空指针： 使用 delete 或 free 释放了内存后，没有将指针设置为 nullptr，指针仍然指向已释放的内存地址。

返回局部变量的指针 : 如果函数返回了指向其局部变量的指针，一旦函数返回，这些局部变量的生命周期结束，返回的指针成为野指针。

越界访问：指针访问的内存超出了其合法的内存块边界。

函数参数指针被释放。

如何避免野指针

在释放内存后将指针置为 nullptr 。
避免返回局部变量的指针。
使用智能指针（如 std::unique_ptr 和 std::shared_ptr ）。
注意函数参数的生命周期，小心在函数内处理通过指针或引用传递的资源，尤其是避免在函数内部释放传递进来的指针所指向的内存。

## 4.2
c++面对对象三大特性

封装 继承 多态

面向对象编程是C++的核心特性之一。OOP是一种编程范式，通过它，程序可以以对象的形式组织数据和功能，并通过对象之间的交互来实现任务。面向对象编程具有封装、继承和多态三个主要特性：

封装：将客观事物封装成为抽象的类, 类把自己数据和方法进行隐藏，仅对外公开接口来和对象进行交互，防止外界干扰或不确定性访问。
继承：指一个类（称为子类或派生类）可以从另一个类（称为父类或基类）中继承属性和行为的能力。通过继承，子类可以重用父类的代码，并且可以在不修改父类的情况下添加新的功能或修改已有的功能。继承使得代码具有层次性和可扩展性，能够建立起类之间的层次关系。
多态：多态是指同一个操作作用于不同的对象时，可以有不同的解释和行为。多态性允许以统一的方式处理不同类型的对象，从而提高了代码的可扩展性和可维护性。在C++中，**多态性通常通过虚函数（virtual functions）来实现。**通过基类中定义虚函数，并在派生类中重新定义该函数，可以实现运行时的动态绑定。

c++的重载和重写，区别和实现方式
重载是同名但是不同的人，重写是转生了

重载和重写是两种不同的概念，它们都用于实现多态性，但方式和使用场景有所不同。
重载：在同一个类或命名空间中，声明多个同名函数， 但是参数列表不同。编译器根据参数的类型、数量或顺序来区分不同的函数。
重写：重写发生在继承体系中，在子类中，声明一个与父类中虚函数具有相同名称、相同参数列表和相同返回类型的函数，并在子类函数前加上 override 关键字。
区别：
作用域：重载发生在同一个作用域内，而重写发生在继承体系中。
参数列表：对于重载的函数，参数列表必须不同；对于重写的函数，参数列表必须与被重写的函数完全相同。
返回类型：重载函数的返回类型可以不同，但重写函数的返回类型必须与被重写的函数相同（或与之兼容，C++中称为协变返回类型）。
虚函数：重写通常与虚函数一起使用，以实现运行时多态性；而重载是编译时多态性，由编译器在编译期间确定调用哪个函数。
关键字：重写函数可以使用 override 关键字，明确指出该函数是对父类虚函数的重写。


## 4.3
c++怎么实现多态(day 4.3)
答：
C++ 的多态分为编译时多态（也被称为静态多态）和运行时多态（也被称为动态动态）
编译时多态
函数重载（Function Overloading）:允许在同一作用域内声明多个同名函数，只要它们的参数列表不同。
运算符重载（Operator Overloading）: 允许为自定义类型定义或修改运算符的行为。
模板（Templates）: 允许创建泛型类和函数，它们可以在多种数据类型上使用。
编译时多态在编译期间就确定了具体的函数或类型，由编译器根据函数的签名或模板实例化来选择正确的函数或实例。

运行时多态: 运行时多态主要通过虚函数和抽象类实现，父类中定义声明虚函数，子类实现对虚函数的重写。由虚函数表和虚函数指针在运行时确定调用哪个函数。
虚函数（Virtual Functions）: 虚函数在基类定义，派生类可以重写这些虚函数。
抽象类（Abstract Classes）: 包含至少一个纯虚函数的类，不能被实例化，但可以作为其他类的基类。
运行时多态实现原理：
运行时多态涉及到虚函数表（**vtable****）**和虚函数指针（vptr）。当类包含虚函数时，编译器会自动为该类创建一个虚函数表，表中包含类中所有虚函数的地址。
子类的虚函数表继承了父类的虚函数表，但会使用自己重写的虚函数将虚函数表中对应的虚函数进行覆盖。
当通过基类指针或引用调用虚函数时，程序会根据对象的实际类型在运行时查找正确的函数地址并调用相应的函数，实现多态。


虚函数和纯虚函数的区别(day4.3)
答：
虚函数和纯虚函数都用于实现多态。

虚函数
虚函数是在普通函数之前加一个 virtual 关键字
虚函数是在基类中声明的，并且可以在派生类中被重写。
虚函数可以有实现，也就是说，基类中的虚函数可以有一个定义，派生类可以选择提供自己的实现，也可以使用基类的实现。
通过虚函数，可以在基类指针或引用中实现动态绑定，即在运行时确定调用哪个类中的函数实现。
纯虚函数
纯虚函数是在虚函数后面加一个 =0 
纯虚函数也是在基类中声明的，但它没有实现，只有声明。
当一个类包含至少一个纯虚函数时，它就成为了一个抽象类，这意味着你不能实例化这样的类，但可以声明这种类型的指针或引用。
区别
是否实现:

虚函数提供函数声明和实现，即提供虚函数的默认实现。
纯虚函数没有函数具体实现，只提供函数声明。
派生类是否实现

派生类可以选择是否覆盖虚函数的默认实现。
当一个类包含至少一个纯虚函数时，派生类必须提供具体实现，否则他们也变成抽象类。
实例化:

包含纯虚函数的类是抽象类，不能被实例化；
而包含虚函数的类不一定是抽象类，可以被实例化，除非它也包含纯虚函数。
目的:

虚函数用于提供一个可以在派生类中被重写的方法实现；
通过纯虚函数，抽象类提供一种接口规范，要求派生类必须提供具体实现。
动态绑定:

虚函数支持动态绑定，
纯虚函数由于没有实现，它们本身不参与动态绑定，但可以作为接口的一部分，影响整个类的多态性。

## 4.4
虚函数是怎么实现的
答：
虚函数的实现依赖于一种称为虚函数表的机制。

虚函数表的创建: 当一个类包含虚函数时，编译器会自动为这个类创建一个虚函数表。这个表是一个函数指针数组，每个指针指向一个虚函数的实现。
虚函数表指针: 编译器会在对象的内存布局中添加一个隐式的虚函数表指针（通常是一个指向 vtable 的指针），这样每个对象都可以通过这个指针访问到类的虚函数表。
虚函数的声明: 在类中声明虚函数时，可以使用 virtual 关键字。如果一个函数被声明为虚函数，编译器会在类的 vtable 中为这个函数分配一个入口。
重写虚函数: 当从基类继承并创建派生类时，可以在派生类中重写基类的虚函数。重写的函数会替换掉 vtable 中对应的基类实现。
动态绑定: 当通过基类指针或引用调用虚函数时，程序会使用对象的虚函数表指针来查找正确的函数实现。这个过程称为动态绑定或晚期绑定。
调用虚函数: 程序运行时，当调用一个虚函数时，会先通过对象的虚函数表指针找到 vtable，然后在 vtable 中查找对应的函数指针，并调用该函数。
简短来说，每个类都有一个虚表，里面有这个类的虚函数地址；每个对象都有指向它的类的虚表的指针，这个指针称为虚指针。 当调用虚函数时，编译器会调用对象的虚指针查找虚表，通过虚函数的地址来执行相应的虚函数。


虚函数表是什么

虚函数表是 C++ 中实现运行时多态（动态绑定）的关键机制之一。
虚函数表是一个或多个函数指针的集合，它存储了类中所有虚函数的地址。当类包含虚函数时，编译器会自动为这个类创建一个虚函数表。
虚函数表的主要目的是在运行时能够确定通过基类指针或引用调用的是哪个派生类中的虚函数实现，从而实现动态绑定。
原理
创建虚函数表：当类声明至少一个虚函数时，编译器会为这个类生成一个虚函数表。
虚函数表指针：编译器会为包含虚函数的类的对象添加一个隐藏的虚函数表指针（通常是一个指针或引用），指向类的虚函数表。
调用虚函数：当通过基类指针或引用调用虚函数时，程序会使用对象的虚函数表指针来查找并调用正确的函数实现。

## 4.5
什么是构造函数和析构函数，可以是虚函数吗
构造函数
构造函数是创建对象时自动调用的成员函数，它的作用是初始化成员变量，为对象分配资源，执行必要的初始化操作。

特点

函数名必须与类名相同，且没有返回类型；
可以有多个构造函数；
如果没有为类定义一个构造函数，编译器会自动生成一个默认构造函数，它没有参数，也可能执行一些默认的初始化操作。
构造函数不能是虚函数。

构造函数的主要作用是在创建对象时初始化对象。如果构造函数是虚的，那么在创建对象时就无法确定调用哪个构造函数，因为虚函数的解析是在运行时进行的，而构造函数的调用是在对象创建之前，即编译时确定的。
如果构造函数是虚的，那么在创建派生类对象时，可能会存在多个构造函数候选，这会导致调用哪个构造函数的二义性。
构造函数通常用于分配资源，如内存分配。如果构造函数是虚的，那么在对象创建时就无法保证资源的正确分配。
在C++中，基类的构造函数总是在派生类的构造函数之前调用。如果构造函数是虚的，那么这种调用顺序就无法保证。
构造函数的调用标志着对象生命周期的开始，而虚函数的调用是在对象生命周期内进行的。如果构造函数是虚的，那么在对象生命周期开始之前就无法确定调用哪个构造函数。
析构函数
析构函数是对象生命周期结束时自动调用的函数，它的作用是释放对象占用的资源，执行一些必要的清理操作。

析构函数特点：

函数名为 ~类名 ；
没有参数；
如果没有为类定义一个析构函数，编译器会自动生成一个默认析构函数，执行简单的清理操作。
析构函数可以是虚函数。

虚析构函数可以在运行时实现多态性；
如果基类的析构函数不是虚函数，当通过基类指针去删除派生类对象时，不会调用派生类的析构函数。可能会导致派生类的资源未被正确释放，从而造成资源泄漏

c++构造函数有几种，分别有什么作用

在C++中，构造函数有几种不同的类型，每种都有其特定的作用：

默认构造函数：没有参数的构造函数，用于创建对象的默认实例。
参数化构造函数：带参数的构造函数，允许在创建对象时初始化成员变量。
拷贝构造函数：以同一类的实例为参数的构造函数，用于复制已有对象。
移动构造函数：以同一类的实例的右值引用为参数，用于利用即将销毁的对象的资源。
转换构造函数：允许将其他类型或值隐式转换为当前类类型的实例。
委托构造函数：一个构造函数调用另一个构造函数来完成初始化，可以是同一个类的其他构造函数。
初始化列表构造函数：使用成员初始化列表来初始化成员变量，这是最高效的初始化方式。
常量构造函数：声明为const的构造函数，可以用于创建常量对象。
constexpr构造函数：允许在编译时初始化对象，用于定义和初始化字面量类型的对象。
每种构造函数的使用场景不同，例如：

默认构造函数用于快速创建对象，而不需要显式提供任何初始化参数。
参数化构造函数提供了灵活性，允许在创建对象时定制其状态。
拷贝构造函数和移动构造函数分别用于对象的复制和移动，是实现资源管理的关键。
转换构造函数和委托构造函数提供了更灵活的对象初始化方式。
初始化列表构造函数是C++中推荐的成员初始化方式，因为它可以提高效率。

## 4.7
stl容器
 序列容器
std::vector: 动态数组，提供快速随机访问。
std::deque: 双端队列，提供从两端快速插入和删除的能力。
std::list: 双向链表，提供高效的元素插入和删除。
std::forward_list: 单向链表，每个元素只存储下一个元素的引用。
std::array: 固定大小的数组，具有静态分配的内存。
 关联容器:
std::set: 基于红黑树，存储唯一元素的集合, 会默认按照升序进行排序。
std::multiset: 允许容器中有多个相同的元素。
std::map: 基于红黑树，存储键值对的有序映射。
std::multimap: 允许映射中有多个相同的键。
std::unordered_set: 基于哈希表，提供平均时间复杂度为 O(1)  的查找。
std::unordered_map: 基于哈希表，存储键值对的无序映射。
 容器适配器（Container Adapters）:
std::stack: 后进先出（LIFO）的栈。
std::queue: 先进先出（FIFO）的队列。
std::priority_queue: 优先队列，元素按优先级排序。

深拷贝与浅拷贝的区别
浅拷贝
定义：浅拷贝仅复制对象本身，不复制对象所指向的动态分配的内存。换句话说，它只复制内存中的对象副本，而不复制对象内部指向的任何动态分配的资源。

实现：通常通过复制构造函数或赋值运算符实现。

特点：

速度快，因为只涉及基本数据类型的复制。
如果原始对象包含指针，浅拷贝会导致两个对象尝试管理相同的动态内存，这可能导致多重释放和悬空指针问题。
深拷贝
定义：深拷贝不仅复制对象本身，还递归地复制对象所指向的所有动态分配的内存。这意味着每个对象都有自己的独立资源副本。

实现：通常需要自定义复制构造函数或赋值运算符来确保所有动态分配的资源都被正确复制。

特点：

速度慢，因为需要递归地复制所有资源。
可以安全地使用复制出的对象，而不担心资源管理问题。

## 4.8
vector和list的区别
vector
基于动态数组：std::vector 基于可以动态扩展的数组实现，这意味着它在内存中连续存储元素。

随机访问：提供快速的随机访问能力，可以通过索引快速访问任何元素。

内存分配：通常在内存分配上更紧凑，因为元素紧密排列，没有额外的空间用于链接或指针。

时间复杂度：

元素访问：O(1)，即常数时间复杂度。
插入和删除：在 vector 的末尾是 O(1)，但如果需要在中间插入或删除元素，则可能需要 O(n)，因为可能需要移动后续所有元素。
内存管理：使用连续内存分配，可以利用缓存的优势，提高访问速度。

list
基于双向链表：std::list 是基于双向链表的容器，每个元素通过节点链接到前一个和后一个元素。

非连续存储：元素在内存中不是连续存储的，每个元素包含指向前一个和后一个元素的指针。

时间复杂度：

元素访问：O(n)，需要从头开始遍历到所需位置。
插入和删除：非常快速，特别是当需要在列表中间插入或删除元素时，操作是 O(1)，前提是已经拥有指向待插入或删除元素的迭代器。
内存管理：由于元素间通过指针链接，内存分配可能更分散，但插入和删除操作不需要移动其他元素。

使用场景
std::vector：

当你需要快速随机访问元素时。
当你需要在末尾快速添加或删除元素时。
当你关心内存使用效率时。
std::list：

当你需要在列表中间高效地插入或删除元素时。
当你不需要随机访问元素时。
当你需要一个灵活的容器，可以动态地添加和删除元素而不会引起大量的内存复制或移动。

vector的底层原理和扩容过程
答
底层原理
vector 是 C++ 标准库中的一个容器，可以看作是一个动态数组，它的大小可以根据元素的增加而增长。它通过在堆上分配一段连续的内存空间存放元素，支持时间复杂度为 O（1 ) 的随机访问。
vector 底层维护了三个迭代器和两个变量，这三个迭代器分别指向对象的起始字节位置，最后一个元素的末尾字节和整个 vector 分配空间的末尾字节。两个变量分别是 size 和 capacity ，Size 表示当前存储元素的数量，capacity 表示当前分配空间的大小。当创建一个 vector 对象时，会分配一个初始化大小的空间存放元素，初始化空间可以通过构造函数的参数指定，缺省情况下为 0。当对 vector 容器进行增加和删除元素时，只需要调整末尾元素指针，而不需要移动整个内存块。
扩容机制
当添加元素的数量达到当前分配空间的大小时，vector 会申请一个更大的内存块，然后将元素从旧的内存块拷贝到新的内存块中，并释放旧的内存块。 扩容可能导致原有迭代器和指针失效，扩容完成后，容器返回指向新内存区域的迭代器或指针。

vector 扩容的机制分为固定扩容和加倍扩容。

固定扩容就是在每次扩容时在原容量的基础上增加固定容量。但是固定扩容可能会面临多次扩容(扩容的不够大)的情况，时间复杂度较高。
加倍扩容就是在每次扩容时原容量翻倍，优点是使得正常情况下扩容的次数大大减少，时间复杂度低，缺点是空间利用率低。

## 4.9
push_back和emplace_back的区别
答：
push_back()和emplace_back()都是C++标准库容器（如std::vector）中用来添加元素的方法，但它们在添加元素的方式上有所不同：

push_back()：

语法是container.push_back(value);，传入的是一个值或对象的副本/移动版本。

它接受一个元素的副本或移动该元素，然后将其添加到容器的末尾。

这个方法需要先构造一个元素的副本或移动构造一个临时对象，然后再将其添加到容器中。

emplace_back()：

语法是container.emplace_back(args...);，传入的是构造新元素所需的参数列表。

它使用就地构造（emplace）的方式，直接在容器的内存空间中构造新元素。

这个方法避免了元素的复制或移动操作，因为它直接在容器的末尾空间构造新元素。

性能：

emplace_back()通常比push_back()更高效，因为它避免了额外的复制或移动操作。
当构造函数需要大量资源时，emplace_back()的优势更加明显。

map deque和list的实现原理
std:: map
基于红黑树：std::map 基于一种自平衡的二叉搜索树——红黑树实现。
有序容器：元素按照键的顺序自动排序，通常是按照小于（<）运算符定义的顺序。
唯一键：每个键都是唯一的，不允许有重复的键。
时间复杂度：提供对数时间复杂度 （O(log n)） 的查找、插入和删除操作。
迭代器：由于 std::map 是基于树的，迭代器在遍历时是有序的。
std::list
基于双向链表：std::list 是一个双向链表，每个元素都持有指向前一个和后一个元素的指针。
无序容器：元素在容器中没有特定的顺序。
插入和删除：提供高效的插入和删除操作，特别是当需要在容器中间插入或删除元素时。
时间复杂度：提供线性时间复杂度 （O(n)） 的查找操作，但插入和删除可以在 O(1) 时间内完成，前提是已经拥有指向待插入或删除元素的迭代器。
迭代器：由于  std::list 是线性结构，迭代器在遍历时是顺序的，但不支持随机访问。
std::deque
基于动态数组：std::deque 是一个基于动态数组的序列容器，可以高效地从两端添加或删除元素。
允许序列操作：可以快速地在队列的前端和后端添加或删除元素。
时间复杂度：提供常数时间复杂度 （O(1)） 的前端和后端插入和删除操作。中间插入或删除操作可能需要 O(n)  时间。