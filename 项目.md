# cache

git clone 之后几个命令行就跑完了 很轻松嘛 接下来是看项目解读，然后自己写一个 加油 我可以的
![alt text](images\cache-result-image.png)

项目文档：[输入密码 · 语雀 《缓存系统（C++）》](https://www.yuque.com/chengxuyuancarl/ctp2tl/nl447lmng4x0sv6q) 密码：ltpi

缓存基本上可以存在任何地方

从用户请求数据到数据返回，数据经过了浏览器、CDN、代理服务器、应用服务器，以及数据库各个环节。每个环节都可以运用缓存技术。从浏览器/客户端开始请求数据，通过HTTP配合CDN获取数据的变更情况，到达代理服务器(Nginx)可以通过反向代理获取静态资源。再往下来到应用服务器可以通过进程内（堆内）缓存，分布式缓存等方式获取数据。如果以上所有缓存都没有命中数据，才会回源到数据库。

缓存的顺序：用户请求->HTTP缓存->CDN缓存->代理服务器缓存->进程内缓存->分布式缓存->数据库

距离用户越近，缓存能够发挥的效果越好。

##  LRU
LRU：设计按照其被访问的时间形成一个有序序列，最久未被使用的数据应该最早被淘汰掉，即当缓存空间被占满时，缓存内最长时间未被使用的数据将被淘汰掉。

可以用map来做，查到一个key value就+1  双向链表及哈希表结合 表头放最久没有使用，表尾放刚刚使用

主要函数：

1. 初始化
2. 访问缓存数据(get)，查key，如果已经存在就返回key，并且复制访问的值，把该值插入到R（insert），把原来的值删除（remove），如果不存在就返回-1
3. 加入数据key(put)：key已经存在就改变value，不在就在表尾插入这组key-value，（insert）超过capacity要逐出最久未使用关键词（remove）

LRU的缺点
1. 如果是12341234这种访问模式的话可能会反复输入输出同样的值
2. 如果冷门数据挤走了热门数据，就不容易清出去，降低缓存利用率
3. 多线程高并发的访问下，同步等待将是一笔极大的时间开销。


定时过期LRUcache：
设置一个全局ttl，在node里面设置一个过期时间的变量，insert的时候初始化一个新的node时间是Curtime+ttl，然后get的时候检查过期没，如果过期了就返回-1，没过期就返回key然后重新更新一下时间，没找到也返回-1，put的时候，如果要删除，依然删除L那边的数据，更新的时候都要重新设置时间

不定时过期LRUCache:
get的时候就算找到了要保持过期时间不变，insert的时候才更新过期时间，put的参数加上一个ttl，每个东西的时间可以不同



LRU-k:将原先进入缓存队列的评判标准从访问一次改为访问K次，可以说朴素的LRU算法为LRU-1

一般情况下，当k的值越大，缓存的命中率越高，但也使得缓存难以淘汰。综合来说，k = 2 时性能最优。



HashLfuCache引入哈希算法，将缓存数据分散到N个LfuCache上，查询时也按照相同的哈希算法，先获取数据可能存在的分片，然后再去对应的分片上查询数据。这样可以增加lfu的读写操作的并行度，减少同步等待的耗时。


LRU(LFU)分片之后淘汰的元素就不是全局中访问最近最不经常访问的元素了(全局的minFreq_)，淘汰的就是局部minFreq_，这里是可以接受的，因为可能某个分片LRU(LFU)中存着大量元素，下一个元素还分给这个LRU(LFU)分片的话，就应该将当前的LRU(LFU)中最近最不经常访问的元素剔除而不是全局的最近最不经常访问元素，然后将新元素添加进来。

## LFU
把使用频率最小的数据置换出去。这种算法更多是从使用频率的角度（但是当缓存满时，如果最低访问频次的缓存数据有多个，就需要考虑哪个元素最近最久未被访问）去考虑的。

数据节点的值：key value frequance（初始化为1）

访问的时候频率+1，丢掉的时候丢频率最低的

LRU 与 LFU 二者的区别：

LRU 是根据时间维度来选择将要淘汰的元素，即删除掉最长时间没被访问的元素。

LFU 是根据频数和时间维度来选择将要淘汰的元素，即首选删除访问频数最低的元素。如果两个元素的访问频数相同，则淘汰最久没被访问的元素。

 实现 LFU 用到了 2 个哈希表，分别用来记录 key - Node （ 用于快速获取数据中 key 对应的节点信息）及 freq - freqList（为每个访问频数构造一个双向链表，并且用哈希表联系二者关系） 两种映射关系

 还要维护一个minFreq：要淘汰数据的时候要用这个去找要求掉的节点

 数据结构：

 节点：（key,val,fre）
 
 链表：(key,val,fre,pre,next)
 
 缓存空间大小
 
 节点哈希表
 
 频率哈希表
 
 最小频率

 private函数：从链表删除（前指针接前面，后指针接后面），加入链表（先找有没有在频率哈希表中），加在R后面

 公共函数

 构造函数：capacity和最小频率

 put：找到了就直接把val更新一下，没找到（1）容量超了（多出来的情况）：找到频率最小的节点，在链表中删除，在节点哈希表删除加入一个频率为1的新节点，加入节点哈希，更新频率哈希，在双向链表中插入

 get:找到了该节点就返回值，删除该节点然后在链表后面再加上，增加频率，如果只有这个节点最小频率++，没找到返回-1
