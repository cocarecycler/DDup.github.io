# 1 两数之和（简单）

1. 用unordered_map忘记怎么插入了，可以用insert({a,b})

# 2字母异位词分组（中等）

1. 一开始用的是set 后来发现要用map
2. 插入的时候可以直接插，不用区分在不在集合里面
3. 循环的时候要用迭代器 auto it =map.begin()

# 3最长连续序列（中等）
1. 老是超时,因为我计算每个子序列的长度是每一个元素都计算，实际上可以在门口查找一下是不是一个序列的头，用检查(cur-1)在不在当前set里面，如果在的话肯定已经查过了
2. 可以用unordered_set<int>sett(nums.begin(),nums.end())
   
# 4 移动0（简单）
1.移动数组里面非0数的时候写错了

# 5盛水最多的容器（中等）
1. 老是超时，我是用面积作为条件，两边往里面嗦，哪个大就动哪个，答案是抛弃小的那个端点，因为小的值肯定想被更新掉

# 三数之和（中等）
1. 一开始没想到固定最开始的算后面的，搞了三层循环+set都没有写出来
2. left和right的加减不要搞错了

# 7 接雨水（困难）
1. 没想到单调栈
2. empty忘记前面加！了
3. 其实理想到单调栈很近了，已经想到要左边右边都比中间高，然后取左右最低值和中间的查作为高了
4. 什么时候想单调栈：要找到左边右边第一个比自己大或者小的数的时候就可以思考单调栈，然后要注意是存数还是存下标
5. 循环i从1开始的时候就不用push(1)了；

# 8无重复字符最长字串（中等）
1. vector.clear()是设置size=0，capacity不变，不i能拿来清零
2. 一开始没懂什么是滑动窗口
3. set去掉值可以用erase(a),插入值用insert(a),虽然set没有顺序，但是这个跟数组用法差不多
4. 注意右边的边界条件，会导致结果+1或者-1

# 9 找到字符串中的所有字母异位词（中等）
1. 要记得滑动窗口划出去的是当前i的上一个值，不定长滑动窗口先判定再看要不要滑进来
2. vector可以直接比较是否相等
3. 计数的时候字母-'a'，数字-'0'

# 10 和为k的子数组（中等）
前缀和+哈希表
要记得查前缀的时候把前缀[0]=1额外加进去，表示空数组的前缀和是0，这个是为了保证数组里面的值本身等于所求target的时候，在map里面找a-a=0不会漏掉

# 11滑动窗口最大值（困难）
单调队列，没有想dao

# 12 最小覆盖字串（困难）
滑动窗口的题
1. 可以用哈希表装被比较的字符和比较的字符串，然后更新哈希表是在遇到被比较的字符串里面存在的字母的时候
2. 设置一个check函数判断当前区间有没有满足条件，先通过不断往右，然后每次循环找的时候判断有没有找到满足条件的区间，找到了就开始把左边界往右移动直到不满足条件
3. substr：s是字符串，s.sunstr(开始位置，长度)
4. 初值设置，l初始是0，r初始是-1，最小长度初始要设置成最大值
   

# 13 最大子数和（中等）
一下子就过了，原来不用前缀和

0927 6道 到合并区间了

# 14 合并区间（中等）
1. 可以先对输入二维数组排序的，二维数组排序的元素是一维数组，比较是按照字典序比较，就是从第一个元素开始比较，有一个有大小差别就可以判断谁大，先排序可以把二维数组里面的一维数组限制在从左到右，不然要多讨论2种情况(在左边包含或者左边分离)
2. 排序之后判断条件可以改成当前遍历到的数组的左边小于res里面最后一个值的 右边，因为排序之后后一个数组的左边界一定在前一个数组左边界的右边
3. 不用专门单独设置两个变量来收集答案数组的左边和右边了可以直接取出res.back()就是一个数组，可以用res.back()[0]
4. 不重叠的话记得把区间塞进答案数组 

# 15 轮转数组（中等）
一遍过了捏，用的是先转整体然后分两部分转

其它两种方法一个是用一个额外的数组，一个是用一个temp，每次更新的位置和上一个隔k个，一共要走a圈，b个元素，最终要回到原点，所以有an（n是数组长度）=bk,第一次回到原点就要结束，所以an是nk的最小公倍数，最后要遍历整个序列的次数是n和k的最大公约数

# 16 除自身以外的数组乘积（中等）
一遍过了前缀积乘后缀积
方法2：取消后缀积，用一个r累乘，其实原理上没有区别，减小了空间复杂度
# 17 缺失的第一个正数（困难）
1. 要求时间复杂度是 o（n），空间复杂度是常熟，但是为什么数组长度n是常熟
2. 不能用哈希表但是可以用数组代替
3. 第一次循环的时候只处理负数和0，因为第二次的时候遍历要用数组元素-1，所以0会报错，第二次再统一把正数变成负数

# 17 矩阵置0 （中等）

1. 要用两个数组标记要不要置零->用第一行第一列标价
2. 循环i++j--写错了，二维数组第一个值是行数，i来控制，第二个是列数
3. 最后一行开始赋值不是最后一列
4. 把循环范围写好，不要搞错了

# 18 螺旋矩阵（中等）
1.  要用四个边界条件控制，单纯用cur一个整体的数控制好像不够
2.  注意边界条件
3.  向左和向上的过程中要加上边界检查条件左边比右边小或者上面比下面小，防止单行单列影响
4.  

# 19.旋转图像（中等
先按照原点旋转再上下反转
1. 主对角线是x+y<=n,副对角线是x《y的区分

# 20 搜索二维矩阵Ⅱ（中等
一列最顶上的数是当列最小的数，从右上开始找，比现在这个数小的target只能在当前列的左边，就可以完全抛弃这一列，找到可能在当前列范围内的数在进入列开始找，对于行来说，从最右边开始找，如果target大于当前行的最右边的数就可以完全排除这一行


# 21 相交链表（简单
 一遍过了（成功人士的表情，虽然只是简单题）

# 22 反转链表（简单
当前取下来的节点，要保存next不然会报错（因为指向同一个节点的话会一起移动过去）

# 23 回文链表（简单
把后面一截反过来然后比后面一截，奇数串的话多余的一个数放在前面一截
1. 中间的位置找错了
2.  最后比较的时候注意比的是后面那一节
10.06->17 18 19 20 21 22 23

# 24 环形链表（简单）
没啥好说的（哼哼）

# 25环形链表Ⅱ（中等）
终于搞清楚怎么找到环入口了，因为快指针进入环之后一直在打转，遇到慢指针的时候假设在环里的长度是b，到环入口的长度是c，头到环入口的直线距离是a可以求出快指针路程是a+（n-1）（b+c）+b，然后满指针是a+b，且快指针路程是慢指针的两倍，求出c=a，所以慢指针和头再走一遍遇到的时候就是环入口

# 26 合并两个有序链表（简单）
这种要一个一个比较的链表要设置一个不动的头节点，和一个随时在动的尾节点不然更新不了

# 27 两数相加（中等）
1. 相加的时候不要忘记移动l1和l2
2. 不要忘记如果有进位的话要在后面再加一个节点
3. 可以用或代替且就是要单独判断第一次和最后一次的情况

# 28 删除链表的倒数第n个节点（中等）
1. 可以用栈，依次入栈，弹出的第n个节点就是要删除的节点，栈顶就是前驱节点
2. 一遍过了，但是不用统计列表长度的话，直接用一个虚拟头节点就可以了

# 29 两两交换链表中的节点（中等）
在while里面用prev限制，先更新prev后面要交换的节点再进行交换，不然链表的关系会乱掉

# 30 k个一组翻转链表（困难）
反转指针的方式：
设施一个新的节点newhead=nullptr；然后当前指针是cur；
temp=cur->next;cur->next=newhead;newhead=cur;cur=temp;
这样循环就可以让cur一步一步退后

注意反转之前要保存链表的两个链接位置，不然会断链

反转链表的操作在tail往后找到本次反转边界之后，不在循环里面

这个题主要是一个是反转链表的操作不熟悉，一个是防止锻炼的操作不熟悉，卡了好久



10.7 ->24 25 26 27 28 29 30

# 31 随机链表的复制（中等）
没有看懂题目说是，意思是新建立一个链表跟原来的链表一模一样，深拷贝大概就是建立一个双胞胎，浅拷贝是镜子，
第一种方法是用一个哈希表存旧节点和新节点的映射，A->A'的映射，然后返回的就是A'，首先递归的建立next的映射，相当于把整个链表重建出来了，然后建立random的映射，这样random到的节点一定是存在的
两次递归之后就把两个指针都处理完了，返回返回的是A’

第二种方法是把新的节点放在旧节点后面AA'BB'CC'这样存着，random也是用的旧指针的random的next，因为毕竟是新的就在旧的后面，然后用一个新节点把处理好的链表取出来,取出来的时候的循环条件是next不是next的next，因为循环中要把链表上的新节点取出来

# 32 排序链表（中等）
逆天，为什么序列的长度是常数啊
放进数组去然后sort然后又构造一个新的链表，但是我看这个方法被题解嘲笑了
1. 快排在时间复杂度最差的情况下是n²不满足要求
2. 先把数据左右左右拆分出来到1然后用合并有序链表又和回去，这个能其效果因为合并1和2的时候 是对的
3. 还有一种方法是从长度1，2，4这样合并到最后，可以做到常熟级别的空间复杂度，每次合并两个链表，没写

# 33 合并k个有序链表(困难)
直接两个两个合并一下子就写出来了，后面的方法是在这个方法上的优化，一种是两两合并的树状合并方法，修改的点是在mergetwo函数中把参数变成(数组，第一个坐标，第二个坐标)，然后分治法的思想跟上面一题一样用是是mergetwo(分左边，分右边)，第三种思路是用优先级队列

优先级队列本来是大顶堆，大的在头上，对应的是<符号返回的就是小于，修改这个小于符号返回的情况，可以变成小顶堆

.用于访问成员，->用于访问指针

# 34LRU缓存（中等）
完全忘记是用哈希家双向链表做了，哈希保证快速找到，双向链表保证时效性，基础函数是remove：从链表里面删掉以及从哈希表里面erase掉要删除的节点，insert：在R的前面加入一个新的节点（用新的key和val构造）然后在哈希表里面加入
在此基础上的函数：put（找到了的话更新key对应的val，是构造一个新节点，删除旧节点，插入新节点，找不到的话，如果小于容量就直接加入，大于就从l后面删掉一个，再插入），get（找到节点，remove，insert，然后返回值）

# 35 二叉树的中序遍历（简单）
只要加上一个引用事情就会被解决
迭代方法的循环条件写错了，应该是root！=null我写的！root

# 36 二叉树最大深度（简单）
思路是对的但是没看出来直接写就可以了，又另外写了一个递归然后没做出来。哦哦做出来了，return里面如果有+1的话，传进去递归的参数就不要再有了，会是两倍的结果

# 37 翻转二叉树(简单)

递归遍历从叶子节点开始反转，当前遍历的左子树右子树如果都反转了那就整个都翻转完了
10.8 31 32 33 34 35 36 37