# 1 两数之和（简单）

1. 用unordered_map忘记怎么插入了，可以用insert({a,b})

# 2字母异位词分组（中等）

1. 一开始用的是set 后来发现要用map
2. 插入的时候可以直接插，不用区分在不在集合里面
3. 循环的时候要用迭代器 auto it =map.begin()

# 3最长连续序列（中等）
1. 老是超时,因为我计算每个子序列的长度是每一个元素都计算，实际上可以在门口查找一下是不是一个序列的头，用检查(cur-1)在不在当前set里面，如果在的话肯定已经查过了
2. 可以用unordered_set<int>sett(nums.begin(),nums.end())
   
# 4 移动0（简单）
1.移动数组里面非0数的时候写错了

# 5盛水最多的容器（中等）
1. 老是超时，我是用面积作为条件，两边往里面嗦，哪个大就动哪个，答案是抛弃小的那个端点，因为小的值肯定想被更新掉

# 三数之和（中等）
1. 一开始没想到固定最开始的算后面的，搞了三层循环+set都没有写出来
2. left和right的加减不要搞错了

# 7 接雨水（困难）
1. 没想到单调栈
2. empty忘记前面加！了
3. 其实理想到单调栈很近了，已经想到要左边右边都比中间高，然后取左右最低值和中间的查作为高了
4. 什么时候想单调栈：要找到左边右边第一个比自己大或者小的数的时候就可以思考单调栈，然后要注意是存数还是存下标
5. 循环i从1开始的时候就不用push(1)了；

# 8无重复字符最长字串（中等）
1. vector.clear()是设置size=0，capacity不变，不i能拿来清零
2. 一开始没懂什么是滑动窗口
3. set去掉值可以用erase(a),插入值用insert(a),虽然set没有顺序，但是这个跟数组用法差不多
4. 注意右边的边界条件，会导致结果+1或者-1

# 9 找到字符串中的所有字母异位词（中等）
1. 要记得滑动窗口划出去的是当前i的上一个值，不定长滑动窗口先判定再看要不要滑进来
2. vector可以直接比较是否相等
3. 计数的时候字母-'a'，数字-'0'

# 10 和为k的子数组（中等）
前缀和+哈希表
要记得查前缀的时候把前缀[0]=1额外加进去，表示空数组的前缀和是0，这个是为了保证数组里面的值本身等于所求target的时候，在map里面找a-a=0不会漏掉

# 11滑动窗口最大值（困难）
单调队列，没有想dao

# 12 最小覆盖字串（困难）
滑动窗口的题
1. 可以用哈希表装被比较的字符和比较的字符串，然后更新哈希表是在遇到被比较的字符串里面存在的字母的时候
2. 设置一个check函数判断当前区间有没有满足条件，先通过不断往右，然后每次循环找的时候判断有没有找到满足条件的区间，找到了就开始把左边界往右移动直到不满足条件
3. substr：s是字符串，s.sunstr(开始位置，长度)
4. 初值设置，l初始是0，r初始是-1，最小长度初始要设置成最大值
   

# 13 最大子数和（中等）
一下子就过了，原来不用前缀和

0927 6道 到合并区间了

# 14 合并区间（中等）
1. 可以先对输入二维数组排序的，二维数组排序的元素是一维数组，比较是按照字典序比较，就是从第一个元素开始比较，有一个有大小差别就可以判断谁大，先排序可以把二维数组里面的一维数组限制在从左到右，不然要多讨论2种情况(在左边包含或者左边分离)
2. 排序之后判断条件可以改成当前遍历到的数组的左边小于res里面最后一个值的 右边，因为排序之后后一个数组的左边界一定在前一个数组左边界的右边
3. 不用专门单独设置两个变量来收集答案数组的左边和右边了可以直接取出res.back()就是一个数组，可以用res.back()[0]
4. 不重叠的话记得把区间塞进答案数组 

# 15 轮转数组（中等）
一遍过了捏，用的是先转整体然后分两部分转

其它两种方法一个是用一个额外的数组，一个是用一个temp，每次更新的位置和上一个隔k个，一共要走a圈，b个元素，最终要回到原点，所以有an（n是数组长度）=bk,第一次回到原点就要结束，所以an是nk的最小公倍数，最后要遍历整个序列的次数是n和k的最大公约数

# 16 除自身以外的数组乘积（中等）
一遍过了前缀积乘后缀积
方法2：取消后缀积，用一个r累乘，其实原理上没有区别，减小了空间复杂度
# 17 缺失的第一个正数（困难）
1. 要求时间复杂度是 o（n），空间复杂度是常熟，但是为什么数组长度n是常熟
2. 不能用哈希表但是可以用数组代替
3. 第一次循环的时候只处理负数和0，因为第二次的时候遍历要用数组元素-1，所以0会报错，第二次再统一把正数变成负数

# 17 矩阵置0 （中等）

1. 要用两个数组标记要不要置零->用第一行第一列标价
2. 循环i++j--写错了，二维数组第一个值是行数，i来控制，第二个是列数
3. 最后一行开始赋值不是最后一列
4. 把循环范围写好，不要搞错了

# 18 螺旋矩阵（中等）
1.  要用四个边界条件控制，单纯用cur一个整体的数控制好像不够
2.  注意边界条件
3.  向左和向上的过程中要加上边界检查条件左边比右边小或者上面比下面小，防止单行单列影响
4.  

# 19.旋转图像（中等
先按照原点旋转再上下反转
1. 主对角线是x+y<=n,副对角线是x《y的区分

# 20 搜索二维矩阵Ⅱ（中等
一列最顶上的数是当列最小的数，从右上开始找，比现在这个数小的target只能在当前列的左边，就可以完全抛弃这一列，找到可能在当前列范围内的数在进入列开始找，对于行来说，从最右边开始找，如果target大于当前行的最右边的数就可以完全排除这一行


# 21 相交链表（简单
 一遍过了（成功人士的表情，虽然只是简单题）

# 22 反转链表（简单
当前取下来的节点，要保存next不然会报错（因为指向同一个节点的话会一起移动过去）

# 23 回文链表（简单
把后面一截反过来然后比后面一截，奇数串的话多余的一个数放在前面一截
1. 中间的位置找错了
2.  最后比较的时候注意比的是后面那一节
10.06->17 18 19 20 21 22 23

# 24 环形链表（简单）
没啥好说的（哼哼）

# 25环形链表Ⅱ（中等）
终于搞清楚怎么找到环入口了，因为快指针进入环之后一直在打转，遇到慢指针的时候假设在环里的长度是b，到环入口的长度是c，头到环入口的直线距离是a可以求出快指针路程是a+（n-1）（b+c）+b，然后满指针是a+b，且快指针路程是慢指针的两倍，求出c=a，所以慢指针和头再走一遍遇到的时候就是环入口

# 26 合并两个有序链表（简单）
这种要一个一个比较的链表要设置一个不动的头节点，和一个随时在动的尾节点不然更新不了

# 27 两数相加（中等）