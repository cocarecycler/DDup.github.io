# 1 两数之和（简单）

1. 用unordered_map忘记怎么插入了，可以用insert({a,b})

# 2字母异位词分组（中等）

1. 一开始用的是set 后来发现要用map
2. 插入的时候可以直接插，不用区分在不在集合里面
3. 循环的时候要用迭代器 auto it =map.begin()

# 3最长连续序列（中等）
1. 老是超时,因为我计算每个子序列的长度是每一个元素都计算，实际上可以在门口查找一下是不是一个序列的头，用检查(cur-1)在不在当前set里面，如果在的话肯定已经查过了
2. 可以用unordered_set<int>sett(nums.begin(),nums.end())
   
# 4 移动0（简单）
1.移动数组里面非0数的时候写错了

# 5盛水最多的容器（中等）
1. 老是超时，我是用面积作为条件，两边往里面嗦，哪个大就动哪个，答案是抛弃小的那个端点，因为小的值肯定想被更新掉

# 三数之和（中等）
1. 一开始没想到固定最开始的算后面的，搞了三层循环+set都没有写出来
2. left和right的加减不要搞错了

# 7 接雨水（困难）
1. 没想到单调栈
2. empty忘记前面加！了
3. 其实理想到单调栈很近了，已经想到要左边右边都比中间高，然后取左右最低值和中间的查作为高了
4. 什么时候想单调栈：要找到左边右边第一个比自己大或者小的数的时候就可以思考单调栈，然后要注意是存数还是存下标
5. 循环i从1开始的时候就不用push(1)了；

# 8无重复字符最长字串（中等）
1. vector.clear()是设置size=0，capacity不变，不i能拿来清零
2. 一开始没懂什么是滑动窗口
3. set去掉值可以用erase(a),插入值用insert(a),虽然set没有顺序，但是这个跟数组用法差不多
4. 注意右边的边界条件，会导致结果+1或者-1

# 9 找到字符串中的所有字母异位词（中等）
1. 要记得滑动窗口划出去的是当前i的上一个值，不定长滑动窗口先判定再看要不要滑进来
2. vector可以直接比较是否相等
3. 计数的时候字母-'a'，数字-'0'

# 10 和为k的子数组（中等）
前缀和+哈希表
要记得查前缀的时候把前缀[0]=1额外加进去，表示空数组的前缀和是0，这个是为了保证数组里面的值本身等于所求target的时候，在map里面找a-a=0不会漏掉

# 11滑动窗口最大值（困难）
单调队列，没有想dao

# 12 最小覆盖字串（困难）
滑动窗口的题
1. 可以用哈希表装被比较的字符和比较的字符串，然后更新哈希表是在遇到被比较的字符串里面存在的字母的时候
2. 设置一个check函数判断当前区间有没有满足条件，先通过不断往右，然后每次循环找的时候判断有没有找到满足条件的区间，找到了就开始把左边界往右移动直到不满足条件
3. substr：s是字符串，s.sunstr(开始位置，长度)
4. 初值设置，l初始是0，r初始是-1，最小长度初始要设置成最大值
   

# 13 最大子数和（中等）
一下子就过了，原来不用前缀和

0927 6道 到合并区间了

# 14 合并区间（中等）
1. 可以先对输入二维数组排序的，二维数组排序的元素是一维数组，比较是按照字典序比较，就是从第一个元素开始比较，有一个有大小差别就可以判断谁大，先排序可以把二维数组里面的一维数组限制在从左到右，不然要多讨论2种情况(在左边包含或者左边分离)
2. 排序之后判断条件可以改成当前遍历到的数组的左边小于res里面最后一个值的 右边，因为排序之后后一个数组的左边界一定在前一个数组左边界的右边
3. 不用专门单独设置两个变量来收集答案数组的左边和右边了可以直接取出res.back()就是一个数组，可以用res.back()[0]
4. 不重叠的话记得把区间塞进答案数组 

# 15 轮转数组（中等）
一遍过了捏，用的是先转整体然后分两部分转

其它两种方法一个是用一个额外的数组，一个是用一个temp，每次更新的位置和上一个隔k个，一共要走a圈，b个元素，最终要回到原点，所以有an（n是数组长度）=bk,第一次回到原点就要结束，所以an是nk的最小公倍数，最后要遍历整个序列的次数是n和k的最大公约数

# 16 除自身以外的数组乘积（中等）
一遍过了前缀积乘后缀积
方法2：取消后缀积，用一个r累乘，其实原理上没有区别，减小了空间复杂度
# 17 缺失的第一个正数（困难）
1. 要求时间复杂度是 o（n），空间复杂度是常熟，但是为什么数组长度n是常熟
2. 不能用哈希表但是可以用数组代替
3. 第一次循环的时候只处理负数和0，因为第二次的时候遍历要用数组元素-1，所以0会报错，第二次再统一把正数变成负数

# 17 矩阵置0 （中等）

1. 要用两个数组标记要不要置零->用第一行第一列标价
2. 循环i++j--写错了，二维数组第一个值是行数，i来控制，第二个是列数
3. 最后一行开始赋值不是最后一列
4. 把循环范围写好，不要搞错了

# 18 螺旋矩阵（中等）
1.  要用四个边界条件控制，单纯用cur一个整体的数控制好像不够
2.  注意边界条件
3.  向左和向上的过程中要加上边界检查条件左边比右边小或者上面比下面小，防止单行单列影响
4.  

# 19.旋转图像（中等
先按照原点旋转再上下反转
1. 主对角线是x+y<=n,副对角线是x《y的区分

# 20 搜索二维矩阵Ⅱ（中等
一列最顶上的数是当列最小的数，从右上开始找，比现在这个数小的target只能在当前列的左边，就可以完全抛弃这一列，找到可能在当前列范围内的数在进入列开始找，对于行来说，从最右边开始找，如果target大于当前行的最右边的数就可以完全排除这一行


# 21 相交链表（简单
 一遍过了（成功人士的表情，虽然只是简单题）

# 22 反转链表（简单
当前取下来的节点，要保存next不然会报错（因为指向同一个节点的话会一起移动过去）

# 23 回文链表（简单
把后面一截反过来然后比后面一截，奇数串的话多余的一个数放在前面一截
1. 中间的位置找错了
2.  最后比较的时候注意比的是后面那一节
10.06->17 18 19 20 21 22 23

# 24 环形链表（简单）
没啥好说的（哼哼）

# 25环形链表Ⅱ（中等）
终于搞清楚怎么找到环入口了，因为快指针进入环之后一直在打转，遇到慢指针的时候假设在环里的长度是b，到环入口的长度是c，头到环入口的直线距离是a可以求出快指针路程是a+（n-1）（b+c）+b，然后满指针是a+b，且快指针路程是慢指针的两倍，求出c=a，所以慢指针和头再走一遍遇到的时候就是环入口

# 26 合并两个有序链表（简单）
这种要一个一个比较的链表要设置一个不动的头节点，和一个随时在动的尾节点不然更新不了

# 27 两数相加（中等）
1. 相加的时候不要忘记移动l1和l2
2. 不要忘记如果有进位的话要在后面再加一个节点
3. 可以用或代替且就是要单独判断第一次和最后一次的情况

# 28 删除链表的倒数第n个节点（中等）
1. 可以用栈，依次入栈，弹出的第n个节点就是要删除的节点，栈顶就是前驱节点
2. 一遍过了，但是不用统计列表长度的话，直接用一个虚拟头节点就可以了

# 29 两两交换链表中的节点（中等）
在while里面用prev限制，先更新prev后面要交换的节点再进行交换，不然链表的关系会乱掉

# 30 k个一组翻转链表（困难）
反转指针的方式：
设施一个新的节点newhead=nullptr；然后当前指针是cur；
temp=cur->next;cur->next=newhead;newhead=cur;cur=temp;
这样循环就可以让cur一步一步退后

注意反转之前要保存链表的两个链接位置，不然会断链

反转链表的操作在tail往后找到本次反转边界之后，不在循环里面

这个题主要是一个是反转链表的操作不熟悉，一个是防止锻炼的操作不熟悉，卡了好久



10.7 ->24 25 26 27 28 29 30

# 31 随机链表的复制（中等）
没有看懂题目说是，意思是新建立一个链表跟原来的链表一模一样，深拷贝大概就是建立一个双胞胎，浅拷贝是镜子，
第一种方法是用一个哈希表存旧节点和新节点的映射，A->A'的映射，然后返回的就是A'，首先递归的建立next的映射，相当于把整个链表重建出来了，然后建立random的映射，这样random到的节点一定是存在的
两次递归之后就把两个指针都处理完了，返回返回的是A’

第二种方法是把新的节点放在旧节点后面AA'BB'CC'这样存着，random也是用的旧指针的random的next，因为毕竟是新的就在旧的后面，然后用一个新节点把处理好的链表取出来,取出来的时候的循环条件是next不是next的next，因为循环中要把链表上的新节点取出来

# 32 排序链表（中等）
逆天，为什么序列的长度是常数啊
放进数组去然后sort然后又构造一个新的链表，但是我看这个方法被题解嘲笑了
1. 快排在时间复杂度最差的情况下是n²不满足要求
2. 先把数据左右左右拆分出来到1然后用合并有序链表又和回去，这个能其效果因为合并1和2的时候 是对的
3. 还有一种方法是从长度1，2，4这样合并到最后，可以做到常熟级别的空间复杂度，每次合并两个链表，没写

# 33 合并k个有序链表(困难)
直接两个两个合并一下子就写出来了，后面的方法是在这个方法上的优化，一种是两两合并的树状合并方法，修改的点是在mergetwo函数中把参数变成(数组，第一个坐标，第二个坐标)，然后分治法的思想跟上面一题一样用是是mergetwo(分左边，分右边)，第三种思路是用优先级队列

优先级队列本来是大顶堆，大的在头上，对应的是<符号返回的就是小于，修改这个小于符号返回的情况，可以变成小顶堆

.用于访问成员，->用于访问指针

# 34LRU缓存（中等）
完全忘记是用哈希家双向链表做了，哈希保证快速找到，双向链表保证时效性，基础函数是remove：从链表里面删掉以及从哈希表里面erase掉要删除的节点，insert：在R的前面加入一个新的节点（用新的key和val构造）然后在哈希表里面加入
在此基础上的函数：put（找到了的话更新key对应的val，是构造一个新节点，删除旧节点，插入新节点，找不到的话，如果小于容量就直接加入，大于就从l后面删掉一个，再插入），get（找到节点，remove，insert，然后返回值）

# 35 二叉树的中序遍历（简单）
只要加上一个引用事情就会被解决
迭代方法的循环条件写错了，应该是root！=null我写的！root

# 36 二叉树最大深度（简单）
思路是对的但是没看出来直接写就可以了，又另外写了一个递归然后没做出来。哦哦做出来了，return里面如果有+1的话，传进去递归的参数就不要再有了，会是两倍的结果

# 37 翻转二叉树(简单)

递归遍历从叶子节点开始反转，当前遍历的左子树右子树如果都反转了那就整个都翻转完了
10.8 31 32 33 34 35 36 37

# 38 对称二叉树（简单）
递归方式就没写出来，本层递归判断当前两个节点的值是不是相同，也就是判断子树的根节点是不是相同，然后用且递归的判断当前节点的左子树和另一个节点的右子树，当前节点的右子树和另一个节点的左子树是否相同 ，迭代的方法用的是队列不是栈，注意，每次取出两个节点判断，如果当前两个节点为空的话是continue继续判断别的，其它的一样

# 39 二叉树的直径（简单）
一定有一个公共祖先，链接这个公共祖先的左边和右边最远的叶子节点可以让长度最长，所以把问题转变为求最大的左边高度+右边高度，一趟深度优先遍历解决

递归函数的参数有当前遍历的节点，答案，当前节点的最大高度

# 40 二叉树的层序遍历（中等）
无需多言，我爱层序遍历
如果是要直接在数组里面加入数据就不要在定义i的时候定义大小，会默认为定义大小那一坨是0

# 41 将有序数组转化为二叉搜索树（简单）
选中间的数作为新的根节点然后递归的选左右半边中间的数作为左孩子和右孩子，一遍过了。注意边界条件

# 42 验证二叉搜索树（中等）
1. 如果要直接在树上操作的话，直接写只能写出单独判断左子树右子树是不是满足条件的局部情况，无法判断整棵树不满足条件的情况，所以要加上一个lower和upper，对于左子树来说，upper是当前跟节点的值，对于右节点来说，lowwer是根节点的值

2. 还有一种方法是中序遍历，中序遍历迭代法的代码有点忘记了，然后是在取出节点进行遍历的时候比较当前节点跟前一个结点的值，初始化为(long long)INT_MIN-1，这样还在long long 范围内 不会溢出，还能表示比最小值还小的值

# 43 二叉搜索树中第k小的元素（中等）
最基础的想法：中序遍历的结果存在一个数组里面然后取数组的第k个值
在此基础上，中序遍历的时候遍历到第k个跳出循环返回值
进一步地，在原本树的结构上加上计算树的节点数的函数，然后就可以用我之前说的那个根节点左边一定都是比根小的值，最后这种要新定义一个树的结构，刚刚抄了一遍

# 44 二叉树的右视图（中等）
层序遍历，官方解答好像还有深度优先，蛮复杂的，层序遍历一遍过了

# 10.9 38 39 40 41 42 43 44

# 45 二叉树展开为链表（中等）
1. 按照前序遍历的迭代写法写了一下，写的很冗余，有很多情况没有考虑到，问了deepseek之后加上了对于只有右孩子没有左孩子和叶子节点以及栈为空的情况之后终于过了
2. 题解里面的方法是前序遍历是左边孩子最右边的节点的下一个是右孩子，所以找到左边孩子最右边的节点接上右孩子，然后把左孩子移到右边，继续处理右孩子就行

# 46 从前序遍历和中序遍历构造二叉树（中等） 
递归构造，以前序为基础，中序分左右子树构造二叉树

# 47 路径总和Ⅲ（中等）
有递归计算和前缀和+哈希两种方法
第一种方式是先递归算每个节点符合条件的路径数，然后把他们加起来，需要注意中间的计算结果要用 long long保存，传给子树的时候要传入当前的前缀和，在主函数递归的时候是先算根节点的情况，然后递归的算左右孩子的所有情况

第二种是用哈希表保存目前路径的前缀和
count=当前和-target在哈希表中的值，然后回溯的传递到子孩子的计算中

# 48 二叉树的最近公共祖先（中等）
不那么深的祖先不会被更新的原因是要查的两个不会第二次分布在新祖先的两侧，也不会再和当前遍历到值相同了

方法一：递归
找到最近公共祖先的条件：pq分别在当前节点的左子树或者pq本身是公共祖先(自己的值等于要查的值且，另一个值在子树里面)
判断pq在当前节点的左子树或者右子树里面：pq已经存在在左子树或者右子树里面，或者当前值等于pq

方法2：
遍历的作用仅仅是把父节点加入哈希表里面，然后在主函数里找，从p开始往父节点传递，每次令visit=true；然后遍历q，如果找到一个visit=true的就返回这个值 

# 49 二叉树中的最大路径和（困难）
因为要用前缀和其实不用，直接用当前节点值+左边的最大路径和+右边的最大路径和就行
递归的时候返回的是当前值+左右的最大值

注意选左边右边最大值的时候要用0或者左右子树值

困难其实也没有很难，还没有中等题难谁动

# 50 岛屿数量（中等）
dfs/bfs模板题
# 51 腐烂的橘子
难吐了
需要背诵一下bfsdfs的模板解这样
10.10 45 46 47 48 49 50 51


# 52 课程表
拓扑排序：寻找有向图里面有没有环
看题的时候在思考是dfs还是bfs发现确实两个都能做
dfs:
设置一个visited函数和一个valid状态变量
每个节点的visited函数值有未处理，处理中和已经处理过三种状态，对于一个点，在未处理过的时候进入dfs，进去之后第一件事是把visited改成1，然后遍历，遍历过程中如果遇见一个点visited=1就说明遇到环了，valid=false，遍历结束之后返回valid的状态
bfs:统计入度，设置一个ingree函数大小是需要修的课程数，初始化为0，必须初始化不然会报错，然后用一个unordered_map统计哪个指向哪个，这里方向其实影响不大，只要哈希表跟入度的设置是匹配的就行
然后检查入度为0的节点加入queue然后在队列不为空的时候遍历，取出一个节点然后减去相关联的节点的入度，为0就加入队列，每次加入节点的时候计算count
遍历完之后count=要求的节点数就说明没有环，否则就有环

# 53 实现前缀树(Trie)（中等）
学习了前缀树这种数据结构，一个根可能带26个字母表示的孩子节点，所以用trie 数组或者哈希表保存孩子
insert：我一开始以为如果没有找到的话才能插入，看了视频之后感觉也有存在在原先的长词语中间的词汇，这种情况只用把is_end改成true就行了所以不用先判断是否存在
search:找有没有这个单词：遍历到最后返回is_end，如果是同一个单词is_end就是true，如果在中间或者不是一个单词就是false
searchprifx和search基本一样，就是最后返回的是true
题解里面没有写创建一个新的根节点，感觉创建一个比较不容易出错

# 54 全排列（中等）
知道是回溯但是在怎么找到现在数组里面已经存在的数是哪些上被卡住了

# 55 子集 （中等）
一开始的思路是根全排列相同，但是用一个哈希表保存状态，然后发现如果是回溯这样一条路下去，每次index++，就不会产生相同子集，不用哈希表去重

初始的思路是单纯用index，然后，每次进入backtracing函数之后就加入res数组，这样也没错，因为不会有重复值，直接加入就好了

后来看了题解学习了一下加入或者不加入的思路，回溯终止条件是这一条路已经搜索完了，一开始还没有理解，其实就是加入或者不加入都能算结束状态，搜索完的标志是搜索长度达到了数组长度，不是当前结果数组长度=数组长度，不加入就是直接进入下一层递归，搜索长度+1，加入是加入当前数组path之后再进入下一层递归，搜索长度+1

# 56 电话号码的字母组合（中等）
string类型在取数的时候可以当成char取，但是数据结构不能直接转化

要自己把unordered_map的值输入，懒惰了

也是用index控制取出来的数，一开始没有想到

# 57 组合总和（中等）
要用index控制递归，单纯用排序加去重会导致栈错误，调的火大

# 58 括号生成(中等)

递归终止条件要加上左右剩余括号数不要小于0不然会报错

我一开始设置了一个检验函数，就用的栈的那种检验括号的方法，后来发现右括号用的多就一定是无效的，因为前面已经没有左括号可以消耗了
10.19 ->52 53 54 55 56 57 58 
